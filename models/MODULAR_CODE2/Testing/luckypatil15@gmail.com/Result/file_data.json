[
 {
  "code": "#include<iostream>\nusing namespace std;\nclass Matrix\n{\n    private:\n        char **mat;\n        int rows;\n        int column;\n        int r;\n        int c;\n        int **vis;\n        int hops;\n    public:\n        Matrix(){}\n        Matrix(int rows,int column){\n            this->rows=rows;\n            this->column=column;\n            r=0;\n            hops=0;\n            c=0;\n            mat=new char*[rows];\n            vis=new int*[rows];\n            for(int i=0;i<rows;i++){\n                mat[i]=new char[column];\n                vis[i]=new int[column];\n            }\n            for(int i=0;i<rows;i++){\n                for(int j=0;j<column;j++){\n                    mat[i][j]='*';\n                    vis[i][j]=0;\n                    \n                }\n            }\n        }\n        void insert(char **mat1){\n            for(int i=0;i<rows;i++){\n                for(int j=0;j<column;j++){\n                    mat[i][j]=mat1[i][j];\n                    if(mat1[i][j]=='#'){\n                        r=i;\n                        c=j;\n                    }\n                    \n                }\n            }\n        }\n        int di1(){\n            if(r>=0 && r<rows && c+1>=0 && c+1<column){\n                if((mat[r][c+1]=='1'|| mat[r][c+1]=='@') && vis[r][c+1]==0){\n                    r=r;\n                    c=c+1;\n                    vis[r][c]=1;\n                    return 1;\n                }\n                else \n                return 0; \n            }\n            else \n            return 0;\n        }\n        int di2(){\n            if(r+1>=0 && r+1<rows && c>=0 && c<column){\n                if((mat[r+1][c]=='1'|| mat[r+1][c]=='@') && vis[r+1][c]==0){\n                    r=r+1;\n                    c=c;\n                    vis[r][c]=1;\n                    return 1;\n                }\n                else \n                return 0; \n            }\n            else \n            return 0;\n        }\n        int di3(){\n            if(r>=0 && r<rows && c-1>=0 && c-1<column){\n                if((mat[r][c-1]=='1'|| mat[r][c-1]=='@') && vis[r][c-1]==0){\n                    r=r;\n                    c=c-1;\n                    vis[r][c]=1;\n                    return 1;\n                }\n                else \n                return 0; \n            }\n            else \n            return 0;\n        }\n        int di4(){\n            if(r-1>=0 && r-1<rows && c>=0 && c<column){\n                if((mat[r-1][c]=='1'|| mat[r-1][c]=='@') && vis[r-1][c]==0){\n                    r=r-1;\n                    c=c;\n                    vis[r][c]=1;\n                    return 1;\n                }\n                else \n                return 0; \n            }\n            else \n            return 0;\n        }\n        int bt1(){\n            if(r>=0 && r<rows && c+1>=0 && c+1<column){\n                if((mat[r][c+1]=='1'|| mat[r][c+1]=='@') && vis[r][c+1]==1){\n                    mat[r][c]=0;\n                    r=r;\n                    c=c+1;\n                    return 1;\n                }\n                else \n                return 0; \n            }\n            else \n            return 0;\n        }\n        int bt2(){\n            if(r+1>=0 && r+1<rows && c>=0 && c<column){\n                if((mat[r+1][c]=='1'|| mat[r+1][c]=='@') && vis[r+1][c]==1){\n                    mat[r][c]=0;\n                    r=r+1;\n                    c=c;\n                    return 1;\n                }\n                else \n                return 0; \n            }\n            else \n            return 0;\n        }\n        int bt3(){\n            if(r>=0 && r<rows && c-1>=0 && c-1<column){\n                if((mat[r][c-1]=='1'|| mat[r][c-1]=='@') && vis[r][c-1]==1){\n                    mat[r][c]=0;\n                    r=r;\n                    c=c-1;\n                    return 1;\n                }\n                else \n                return 0; \n            }\n            else \n            return 0;\n        }\n        int bt4(){\n            if(r-1>=0 && r-1<rows && c>=0 && c<column){\n                if((mat[r-1][c]=='1'|| mat[r-1][c]=='@') && vis[r-1][c]==1){\n                    mat[r][c]=0;\n                    r=r-1;\n                    c=c;\n                    return 1;\n                }\n                else \n                return 0; \n            }\n            else \n            return 0;\n        }\n        void findpath(){\n            while(mat[r][c]!='@'){\n                if(di1()){\n                    hops++;\n                }\n                else if(di2()){\n                    hops++;\n                }\n                else if(di3()){\n                    hops++;\n                }\n                else if(di4()){\n                    hops++;\n                }\n                else if(bt1()){\n                    hops--;\n                }\n                else if(bt2()){\n                    hops--;\n                }\n                else if(bt3()){\n                    hops--;\n                }\n                else if(bt4()){\n                    hops--;\n                }\n            }\n            cout<<hops<<endl;\n        }\n};\nint main(){\n    int rows;\n    cin>>rows;\n    int column;\n    cin>>column;\n    Matrix m1(rows,column);\n    char **mat1;\n    mat1=new char*[rows];\n    for(int i=0;i<rows;i++){\n        mat1[i]=new char[column];\n    }\n    char data;\n    for(int i=0;i<rows;i++){\n        for(int j=0;j<column;j++){\n            cin>>data;\n            mat1[i][j]=data;\n        }\n    }\n    m1.insert(mat1);\n    m1.findpath();\n}",
  "name": "200240320051_DS-Exam 2.cpp"
 },
 {
  "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nclass Cqueue\n{\n            private:\n                    int front;\n                    int rear;\n                    int size;\n                    int *store;\n            public:\n                    Cqueue(int size)\n                    {\n                            front=rear=-1;\n                            this->size=size;\n                            store=new int[size];\n                    }\n                    ~Cqueue()\n                    {\n                            delete [] store;\n                    }\n                    int isEmpty()\n                    {\n                            if(front==-1)\n                            {\n                                cout<<\"EMPTY\"<<endl;\n                                return 1;\n                            }\n                    \n                            return 0;\n                    }\n                    int isFull()\n                    {\n                            if(front==(rear+1)%size)\n                            {\n                                cout<<\"FULL\"<<endl;\n                                return 1;\n                            }\n                           return 0;\n                    }\n                    \n                    void enque(int data)\n                    {\n                            if(!isFull())\n                            {\n                                if(front==-1)\n                                {\n                                    front=rear=0;\n                                }\n                                else\n                                    rear=(rear+1)%size;\n                                        store[rear]=data;\n                                \n                            }\n                    }\n                    int dqueue()\n                    {\n                            int data;\n                            if(!isEmpty())\n                            {\n                                data=store[front];                        \n                                if(front==rear)\n                                {\n                                    front=rear=-1;\n                                }\n                                else\n                                    front=(front+1)%size;\n                                \n                                    \n                                \n                                            \n                            } return data;\n                    }\n};                    \nint main()\n{   int size;\n    string cmd;\n    int data;\n    cin>>size;\n    Cqueue c1(size);\n            while(1)\n            {           cin>>cmd;\n                \n                        if(cmd==\"exit\")\n                        \n                        {\n                            break;\n                            \n                        }\n                        if(cmd==\"enque\")\n                            {\n                                    cin>>data;\n                                    c1.enque(data);\n                            }\n                        if(cmd==\"deque\")\n                            {\n                                if(!c1.isEmpty())\n                                {  \n                                    cout<<c1.dqueue()<<endl;                            }\n                                }\n\n                            }return 0;\n                    }",
  "name": "200240320051_circular (1).cpp"
 },
 {
  "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nclass Cqueue\n{\n            private:\n                    int front;\n                    int rear;\n                    int size;\n                    int *store;\n            public:\n                    Cqueue(int size)\n                    {\n                            front=rear=-1;\n                            this->size=size;\n                            store=new int[size];\n                    }\n                    ~Cqueue()\n                    {\n                            delete [] store;\n                    }\n                    int isEmpty()\n                    {\n                            if(front==-1)\n                            {\n                                cout<<\"EMPTY\"<<endl;\n                                return 1;\n                            }\n                    \n                            return 0;\n                    }\n                    int isFull()\n                    {\n                            if(front==(rear+1)%size)\n                            {\n                                cout<<\"FULL\"<<endl;\n                                return 1;\n                            }\n                           return 0;\n                    }\n                    \n                    void enque(int data)\n                    {\n                            if(!isFull())\n                            {\n                                if(front==-1)\n                                {\n                                    front=rear=0;\n                                }\n                                else\n                                    rear=(rear+1)%size;\n                                        store[rear]=data;\n                                \n                            }\n                    }\n                    int dqueue()\n                    {\n                            int data;\n                            if(!isEmpty())\n                            {\n                                data=store[front];                        \n                                if(front==rear)\n                                {\n                                    front=rear=-1;\n                                }\n                                else\n                                    front=(front+1)%size;\n                                \n                                    \n                                \n                                            \n                            } return data;\n                    }\n};                    \nint main()\n{   int size;\n    string cmd;\n    int data;\n    cin>>size;\n    Cqueue c1(size);\n            while(1)\n            {           cin>>cmd;\n                \n                        if(cmd==\"exit\")\n                        \n                        {\n                            break;\n                            \n                        }\n                        if(cmd==\"enque\")\n                            {\n                                    cin>>data;\n                                    c1.enque(data);\n                            }\n                        if(cmd==\"deque\")\n                            {\n                                if(!c1.isEmpty())\n                                {  \n                                    cout<<c1.dqueue()<<endl;                            }\n                                }\n\n                            }return 0;\n                    }",
  "name": "200240320051_circular - Copy.cpp"
 },
 {
  "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nclass Cqueue\n{\n            private:\n                    int front;\n                    int rear;\n                    int size;\n                    int *store;\n            public:\n                    Cqueue(int size)\n                    {\n                            front=rear=-1;\n                            this->size=size;\n                            store=new int[size];\n                    }\n                    ~Cqueue()\n                    {\n                            delete [] store;\n                    }\n                    int isEmpty()\n                    {\n                            if(front==-1)\n                            {\n                                cout<<\"EMPTY\"<<endl;\n                                return 1;\n                            }\n                    \n                            return 0;\n                    }\n                    int isFull()\n                    {\n                            if(front==(rear+1)%size)\n                            {\n                                cout<<\"FULL\"<<endl;\n                                return 1;\n                            }\n                           return 0;\n                    }\n                    \n                    void enque(int data)\n                    {\n                            if(!isFull())\n                            {\n                                if(front==-1)\n                                {\n                                    front=rear=0;\n                                }\n                                else\n                                    rear=(rear+1)%size;\n                                        store[rear]=data;\n                                \n                            }\n                    }\n                    int dqueue()\n                    {\n                            int data;\n                            if(!isEmpty())\n                            {\n                                data=store[front];                        \n                                if(front==rear)\n                                {\n                                    front=rear=-1;\n                                }\n                                else\n                                    front=(front+1)%size;\n                                \n                                    \n                                \n                                            \n                            } return data;\n                    }\n};                    \nint main()\n{   int size;\n    string cmd;\n    int data;\n    cin>>size;\n    Cqueue c1(size);\n            while(1)\n            {           cin>>cmd;\n                \n                        if(cmd==\"exit\")\n                        \n                        {\n                            break;\n                            \n                        }\n                        if(cmd==\"enque\")\n                            {\n                                    cin>>data;\n                                    c1.enque(data);\n                            }\n                        if(cmd==\"deque\")\n                            {\n                                if(!c1.isEmpty())\n                                {  \n                                    cout<<c1.dqueue()<<endl;                            }\n                                }\n\n                            }return 0;\n                    }",
  "name": "200240320051_circular.cpp"
 },
 {
  "code": "#include<iostream>\n#include<cstdlib>\nusing namespace std;\nclass Node\n{\n    private:\n        int data;\n        Node *left;\n        Node *right;\n    public:\n        Node(int data)\n            {\n                this->data=data;\n                left=NULL;\n                right=NULL;\n            }\n        ~Node()\n            {\n                delete left,right;\n            }\n        Node *getLeft()\n            {\n                return left;\n            }\n        Node *getRight()\n            {\n                return right;\n            }\n        void setLeft(Node *left)\n            {\n                this->left=left;\n            }\n        void setRight(Node *right)\n            {\n                this->right=right;\n            }\n        int getData()\n            {\n                return data;\n            }\n};\n\nclass Bst\n{\n    private:\n        Node *root;\n        int *arr;\n        int i;\n    public:\n        Bst()\n            {\n                root=NULL;\n                this->arr=arr;\n                arr=new int[50];\n                i=0;\n                \n            }\n        Node *getroot()\n            {\n                return root;\n            }\n            void Size(int size)\n            {\n                i=0;\n                arr=new int[size];\n            }\n      /* void cleararray()\n            {\n                for(int i=0;i<15;i++)\n                    {\n                        arr[i]=-1;\n                    }\n            }*/\n        void insert(int data)\n            { \n                \n                Node*node=new Node(data);\n                if(root==NULL)\n                    {\n                        root=node;\n                    }\n                else\n                    {\n                        Node*temp=root;\n                        Node*prev=root;\n                        while(temp!=NULL)\n                            {\n                                prev=temp;\n                                if(data<=temp->getData())\n                                    {\n                                        temp=temp->getLeft();\n                                    }\n                                else\n                                    {\n                                        temp=temp->getRight();\n                                    }\n                            }\n                        if(prev->getData()>=data)\n                            {\n                                prev->setLeft(node);\n                            }\n                        else\n                            {\n                                prev->setRight(node);\n                            }\n                    }//size++;\n            }\n        void levelprint(Node *root,int lvl)\n            {\n                if(root==NULL)\n                    {\n                        return ;\n                    }\n                    else if(lvl>1)\n                    {\n                        levelprint(root->getLeft(),lvl-1);\n                        levelprint(root->getRight(),lvl-1);\n                    }\n                else if(lvl==1)\n                    {\n                        arr[i]=root->getData();\n                        i++;\n                    }\n                \n            }\n        int height(Node *root)\n            {   \n                int h=0;\n                if(root==NULL)\n                    {\n                        return 0;\n                    }\n                else\n                    {\n                        int l=height(root->getLeft());\n                        int r=height(root->getRight());\n                        if(l>r)\n                            {\n                                h=l+1;\n                            }\n                        else\n                            {\n                                h=r+1;\n                            }\n                        return h;\n                    }\n                    \n            }\n            void print(Node *temp)\n                {\n                      int hgt=height(root);\n                for(int j=1;j<=hgt;j++)\n                     {\n                         levelprint(root,j);\n                         arr[i]=-1;\n                         i++;\n                        //cleararray();\n                    }\n                }\n            void arrprint(int count)\n                {\n                    print(root);\n                    //cout<<size<<endl;\n                    int val;\n                    val=0;\n                         while(val<i)\n                            {\n                                \n                                if(arr[val+1]==-1)\n                                    {\n                                        cout<<arr[val]<<endl;\n                                        val=val+2;\n                                    }\n                                else\n                                    {\n                                        cout<<arr[val]<<\" \";\n                                        val++;\n                                    }\n                            }\n                }\n};\n\nint main()\n{\n Bst b1;\n int data;\n int count=0;\n while(1)\n    {\n        cin>>data;\n        if(data==-1)\n            {\n                break;\n            }\n        b1.insert(data);\n        count++;\n    }\n    /*int hgt=b1.height(b1.getroot());\n    for(int i=1;i<=hgt;i++)\n        {\n            b1.levelprint(b1.getroot(),i);\n            //cout<<b1.levelprint(b1.getroot,i);\n            cout<<endl;\n        }*/ int h=((count)+(count/2));\n        b1.Size(h);\n     //  b1.print(b1.getroot());\n        b1.arrprint(h);\n        return 0;\n}",
  "name": "200240320051_dsexam1 - Copy.cpp"
 },
 {
  "code": "#include<iostream>\n#include<cstdlib>\nusing namespace std;\nclass Node\n{\n    private:\n        int data;\n        Node *left;\n        Node *right;\n    public:\n        Node(int data)\n            {\n                this->data=data;\n                left=NULL;\n                right=NULL;\n            }\n        ~Node()\n            {\n                delete left,right;\n            }\n        Node *getLeft()\n            {\n                return left;\n            }\n        Node *getRight()\n            {\n                return right;\n            }\n        void setLeft(Node *left)\n            {\n                this->left=left;\n            }\n        void setRight(Node *right)\n            {\n                this->right=right;\n            }\n        int getData()\n            {\n                return data;\n            }\n};\n\nclass Bst\n{\n    private:\n        Node *root;\n        int *arr;\n        int i;\n    public:\n        Bst()\n            {\n                root=NULL;\n                this->arr=arr;\n                arr=new int[50];\n                i=0;\n                \n            }\n        Node *getroot()\n            {\n                return root;\n            }\n            void Size(int size)\n            {\n                i=0;\n                arr=new int[size];\n            }\n      /* void cleararray()\n            {\n                for(int i=0;i<15;i++)\n                    {\n                        arr[i]=-1;\n                    }\n            }*/\n        void insert(int data)\n            { \n                \n                Node*node=new Node(data);\n                if(root==NULL)\n                    {\n                        root=node;\n                    }\n                else\n                    {\n                        Node*temp=root;\n                        Node*prev=root;\n                        while(temp!=NULL)\n                            {\n                                prev=temp;\n                                if(data<=temp->getData())\n                                    {\n                                        temp=temp->getLeft();\n                                    }\n                                else\n                                    {\n                                        temp=temp->getRight();\n                                    }\n                            }\n                        if(prev->getData()>=data)\n                            {\n                                prev->setLeft(node);\n                            }\n                        else\n                            {\n                                prev->setRight(node);\n                            }\n                    }//size++;\n            }\n        void levelprint(Node *root,int lvl)\n            {\n                if(root==NULL)\n                    {\n                        return ;\n                    }\n                    else if(lvl>1)\n                    {\n                        levelprint(root->getLeft(),lvl-1);\n                        levelprint(root->getRight(),lvl-1);\n                    }\n                else if(lvl==1)\n                    {\n                        arr[i]=root->getData();\n                        i++;\n                    }\n                \n            }\n        int height(Node *root)\n            {   \n                int h=0;\n                if(root==NULL)\n                    {\n                        return 0;\n                    }\n                else\n                    {\n                        int l=height(root->getLeft());\n                        int r=height(root->getRight());\n                        if(l>r)\n                            {\n                                h=l+1;\n                            }\n                        else\n                            {\n                                h=r+1;\n                            }\n                        return h;\n                    }\n                    \n            }\n            void print(Node *temp)\n                {\n                      int hgt=height(root);\n                for(int j=1;j<=hgt;j++)\n                     {\n                         levelprint(root,j);\n                         arr[i]=-1;\n                         i++;\n                        //cleararray();\n                    }\n                }\n            void arrprint(int count)\n                {\n                    print(root);\n                    //cout<<size<<endl;\n                    int val;\n                    val=0;\n                         while(val<i)\n                            {\n                                \n                                if(arr[val+1]==-1)\n                                    {\n                                        cout<<arr[val]<<endl;\n                                        val=val+2;\n                                    }\n                                else\n                                    {\n                                        cout<<arr[val]<<\" \";\n                                        val++;\n                                    }\n                            }\n                }\n};\n\nint main()\n{\n Bst b1;\n int data;\n int count=0;\n while(1)\n    {\n        cin>>data;\n        if(data==-1)\n            {\n                break;\n            }\n        b1.insert(data);\n        count++;\n    }\n    /*int hgt=b1.height(b1.getroot());\n    for(int i=1;i<=hgt;i++)\n        {\n            b1.levelprint(b1.getroot(),i);\n            //cout<<b1.levelprint(b1.getroot,i);\n            cout<<endl;\n        }*/ int h=((count)+(count/2));\n        b1.Size(h);\n     //  b1.print(b1.getroot());\n        b1.arrprint(h);\n        return 0;\n}",
  "name": "200240320051_dsexam1.cpp"
 },
 {
  "code": "GREEDY :: GREEDY(){}\nGREEDY:: GREEDY(string Pattern_Code,string Text_Code,int  Minimum_Matching_length)\n{\n\tthis -> Pattern_Code = Pattern_Code;\n\tthis -> Text_Code = Text_Code;\n\tVisited_Pattern = new int[Pattern_Code.length()];\n\tVisited_Text = new int[Text_Code.length()];\n\tthis -> Minimum_Matching_length = Minimum_Matching_length;//sensitivity\n\t//initialising visited arrays\n\tfor(int i = 0 ; i < Pattern_Code.length() ; i++)\n\tVisited_Pattern[i] = 0 ;\n\tfor(int i = 0; i < Text_Code.length() ; i++)\n\tVisited_Text[i] = 0;\n}\nint GREEDY::  Dist_To_Next_Tile(int pos,int *vis,int Search_Length,string Code){\n\t\t\tint Dist = 0;\n\t\t\tif(pos + 1 == Code.length()){\n\t\t\t\treturn  Dist;\n\t\t\t}\n\t\t\tfor(Dist = 0; Dist + pos + 1 < Code.length() && vis[Dist + pos + 1] == 0 ; Dist++){//5 6 7 8 9\n\t\t\t\tif(Dist + 1 == Search_Length){\n\t\t\t\t\treturn Dist + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pos + Dist + 1 == Text_Code.length()){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn Dist + 1;\n\t\t}\n\t\t\n\t\tbool GREEDY:: isoccluded (MATCH match){\n\t\t\tint flag = 0;\n\t\t\tfor(int i = match.getIndex_Pattern() ; i < match.getIndex_Pattern() + match.getToken_Matched_Length() ; i++){\n\t\t\t\tif(Visited_Pattern[i] == 1){\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = match.getIndex_text() ; i < match.getIndex_text() + match.getToken_Matched_Length() ; i++){\n\t\t\t\tif(Visited_Text[i] == 1){\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag == 1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return false;\n\t\t}\n\t\tint GREEDY:: Jump_To_Next_Unmarked_Token(int pos,int * vis,int Search_Length,string Text_Code){\n\t\t\tint Dist = Dist_To_Next_Tile (pos ,vis ,Search_Length ,Text_Code);\n\t\t\tif( pos + 1 == Text_Code.length()){\n\t\t\t\treturn  0;\n\t\t\t}\n\t\t\tfor(pos += Dist ; pos + 1 < Text_Code.length() && vis[ pos + 1] == 1 ; pos++){}\n\t\t\tif(pos + 1 > Text_Code.length() - 1){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn pos + 1;\n\t\t}\n\t\tlong long int GREEDY::  String_To_Hashvalue(string s ){\n\t\t\tlong long int n = s.length();\n\t\t\tconst long long int a = pow(10,9);\n\t\t\tlong long int val = 0;\n\t\t\tconst int fval = 31;\n\t\t\tlong long int power = 1;\n\t\t\tchar c ='@';\n\t\t\tlong long int e = n - 1;\n\t\t\tfor(int i = 0 ; i < n ; i++){//85-65\n\t\t\t\tval = ( val + ( ( int(s[i] )- int(c) ) *power ) )%(a+9) ;\n\t\t\t\tpower = ( power * fval ) % (a+9); \n\t\t\t}\n\t\t\treturn val; \n\t\t}\n\n\t\tint GREEDY:: Scan_Pattern (int Initial_Search_Length){\n\t\t\tint Maxmatch_Found = 0;\n\t\t\tint Search_Length = Initial_Search_Length;\n\t\t\tint Text_Position = 0;\n\t\t\tpriority_queue < MATCH > Prior_queue;\n\t\t\tbool No_Next_Tile = false;\n\t\t\twhile(Text_Position < Text_Code.length()){\n\t\t\t\tif(Is_Text_Marked( Text_Position ) ){\n\t\t\t\t\tText_Position++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint Dist = Dist_To_Next_Tile(Text_Position,Visited_Text,Search_Length,Text_Code);\n\t\t\t\t\tif(Dist == 0){\n\t\t\t\t\t\tNo_Next_Tile = true;\n\t\t\t\t\t\tDist=Text_Code.length() - Text_Position;\n\t\t\t\t\t}\n\t\t\t\t\tif(Dist < Search_Length){\n\t\t\t\t\t\tif(No_Next_Tile){\n\t\t\t\t\t\t\tText_Position = Text_Code.length();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tText_Position = Jump_To_Next_Unmarked_Token(Text_Position,Visited_Text,Search_Length,Text_Code);\n\t\t\t\t\t\t\tif(Text_Position == 0){\n\t\t\t\t\t\t\t\tText_Position = Text_Code.length();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstring Substring = \"\";\n\t\t\t\t\t\tfor(int i = Text_Position ; i <= Text_Position+Search_Length-1 ; i++){\n\t\t\t\t\t\t\tSubstring = Substring + Text_Code[i];\n\t\t\t\t\t\t\tHashmap.insert({String_To_Hashvalue(Substring),Text_Position});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tText_Position++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint Pattern_Position = 0;\n\t\t\tNo_Next_Tile = false;\n\n\t\t\twhile(Pattern_Position < Pattern_Code.length()){\n\t\t\t\tif(Is_Pattern_Marked(Pattern_Position)){\n\t\t\t\t\tPattern_Position++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint Dist = Dist_To_Next_Tile(Pattern_Position,Visited_Pattern,Search_Length,Pattern_Code);\n\t\t\t\t\tif(Dist == 0){\n\t\t\t\t\t\tNo_Next_Tile = true;\n\t\t\t\t\t\tDist = Pattern_Code.length() - Pattern_Position;\n\t\t\t\t\t}\n\t\t\t\t\tif(Dist < Search_Length){\n\t\t\t\t\t\tif(No_Next_Tile){\n\t\t\t\t\t\t\tPattern_Position = Pattern_Code.length();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tPattern_Position = Jump_To_Next_Unmarked_Token(Pattern_Position,Visited_Pattern,Search_Length,Pattern_Code);\n\t\t\t\t\t\t\tif(Pattern_Position == 0){\n\t\t\t\t\t\t\t\tPattern_Position = Pattern_Code.length();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t\telse{\n\t\t\t\t\t\tstring Substring = \"\";\n\t\t\t\t\t\tfor(int i = Pattern_Position ; i <= Pattern_Position+Search_Length-1 ; i++){\n\t\t\t\t\t\t\tSubstring = Substring + Pattern_Code[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong long int hash1 = String_To_Hashvalue(Substring);\n\t\t\t\t\t\tauto Index_Text = Hashmap.equal_range(hash1);\n\t\t\t\t\t\tvector < int > Occurance;\n\t\t\t\t\t\tfor(auto itr = Index_Text.first ; itr!=Index_Text.second ; itr++){\n\t\t\t\t\t\t\tOccurance.push_back(itr->second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(Occurance.size() != 0){\n\t\t\t\t\t\t\tfor(int j = 0 ; j < Occurance.size() ; j++ ){\n\t\t\t\t\t\t\t\tint Text_Match_Start = Occurance[j];\n\t\t\t\t\t\t\t\tint Match_Length = 0;\n\t\t\t\t\t\t\t\tstring temp=\"\";\t\t\n\t\t\t\t\t\t\t\twhile(Pattern_Code[Pattern_Position + Match_Length] == Text_Code[Text_Match_Start+Match_Length] && Visited_Pattern[Pattern_Position + Match_Length] == 0 && Visited_Text[Text_Match_Start + Match_Length] == 0){\n\t\t\t\t\t\t\t\t\ttemp = temp + Pattern_Code[Pattern_Position + Match_Length];\n\t\t\t\t\t\t\t\t\tMatch_Length++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(Match_Length > 2 * Search_Length){\n\t\t\t\t\t\t\t\t\tSearch_Length = Match_Length;\t\t\n\t\t\t\t\t\t\t\t\ttemp = \"\";\n\t\t\t\t\t\t\t\t\treturn Match_Length;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(Maxmatch_Found < Search_Length){\n\t\t\t\t\t\t\t\t\tMaxmatch_Found = Search_Length;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(Maxmatch_Found < Match_Length){ \n\t\t\t\t\t\t\t\t\tMaxmatch_Found = Match_Length;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(Match_Length >= Minimum_Matching_length)\n\t\t\t\t\t\t\t\tPrior_queue.push(MATCH(Pattern_Position,Text_Match_Start,Match_Length,temp));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}Pattern_Position++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!Prior_queue.empty()){\n\t\t\t\tMatches_Found.push_back(Prior_queue);\n\t\t\t}\n\t\t\treturn Maxmatch_Found;\n\t\t} \n\t\t\t\n\t\tvoid GREEDY:: Mark_String_Matches (){\n\t\t\tfor(priority_queue<MATCH > Prior_queue:Matches_Found){\n\t\t\t\twhile(!Prior_queue.empty()){\n\t\t\t\t\tMATCH m1 = Prior_queue.top();\n\t\t\t\t\tPrior_queue.pop();\n\t\t\t\t\tif(!isoccluded(m1)){\n\t\t\t\t\t\tfor(int i = 0 ; i < m1.getToken_Matched_Length() - 1 ; i++){\n\t\t\t\t\t\t\tVisited_Pattern[m1.getIndex_Pattern() + i ] = 1 ;\n\t\t\t\t\t\t\tVisited_Text[m1.getIndex_text() + i ]= 1 ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTiles.push_back(m1);\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatches_Found.clear();\n\t\t}\n\t\tvoid GREEDY:: Greedy_Rabin_Karp_Driver(){\n\t\t\t int initsearchSize = 20 ;\n\t\t\tif(Minimum_Matching_length < 3){\n\t\t\t\tMinimum_Matching_length = 3;\n\t\t\t}\n\t\t\tbool stop = false;\n\t\t\tint Search_Length = initsearchSize;\n\t\t\twhile(!stop){\n\t\t\t\tint Lmax = Scan_Pattern(Search_Length);\n\t\t\t\tif(Lmax > 2 * Search_Length){\n\t\t\t\t\tSearch_Length = Lmax;\n\t\t\t\t} \n\t\t\t\telse{\n\t\t\t\t\tMark_String_Matches();\n\t\t\t\t\tif(Search_Length > 2* Minimum_Matching_length){\n\t\t\t\t\t\tSearch_Length /= 2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(Search_Length   > Minimum_Matching_length){\n\t\t\t\t\t\tSearch_Length = Minimum_Matching_length;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstop = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool GREEDY::  Is_Pattern_Marked(int pos){\n\t\t\tif(Visited_Pattern[pos] == 1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\tbool GREEDY::  Is_Text_Marked(int pos){\n\t\t\tif(Visited_Text[pos] == 1){\n\t\t\t\treturn true;\n\t\t\t} \n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\tvoid GREEDY:: tiling(){\n\t\t\tfor(int i = 0 ; i < Tiles.size() ; i++){\n\t\t\t\tcout << \"Tiles = \" << Tiles[i].getmatch() << \" \" << \"Index_Pattern  = \" << Tiles[i].getIndex_Pattern() << \" Index_Text = \" << Tiles[i].getIndex_text() << \" length = \" << Tiles[i].getToken _Matched_Length() << endl ;\n\t\t\t}\n\t\t}\n\n\t\tbool operator < (const MATCH &match1, const MATCH &match2){\n\t\t\treturn match1.getToken_Matched_Length() < match2.getToken_Matched_Length();\n\t\t}\n\n\n",
  "name": "GREEDY_Class - Copy.cpp"
 },
 {
  "code": "GREEDY :: GREEDY(){}\nGREEDY:: GREEDY(string Pattern_Code,string Text_Code,int  Minimum_Matching_length)\n{\n\tthis -> Pattern_Code = Pattern_Code;\n\tthis -> Text_Code = Text_Code;\n\tVisited_Pattern = new int[Pattern_Code.length()];\n\tVisited_Text = new int[Text_Code.length()];\n\tthis -> Minimum_Matching_length = Minimum_Matching_length;//sensitivity\n\t//initialising visited arrays\n\tfor(int i = 0 ; i < Pattern_Code.length() ; i++)\n\tVisited_Pattern[i] = 0 ;\n\tfor(int i = 0; i < Text_Code.length() ; i++)\n\tVisited_Text[i] = 0;\n}\nint GREEDY::  Dist_To_Next_Tile(int pos,int *vis,int Search_Length,string Code){\n\t\t\tint Dist = 0;\n\t\t\tif(pos + 1 == Code.length()){\n\t\t\t\treturn  Dist;\n\t\t\t}\n\t\t\tfor(Dist = 0; Dist + pos + 1 < Code.length() && vis[Dist + pos + 1] == 0 ; Dist++){//5 6 7 8 9\n\t\t\t\tif(Dist + 1 == Search_Length){\n\t\t\t\t\treturn Dist + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pos + Dist + 1 == Text_Code.length()){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn Dist + 1;\n\t\t}\n\t\t\n\t\tbool GREEDY:: isoccluded (MATCH match){\n\t\t\tint flag = 0;\n\t\t\tfor(int i = match.getIndex_Pattern() ; i < match.getIndex_Pattern() + match.getToken_Matched_Length() ; i++){\n\t\t\t\tif(Visited_Pattern[i] == 1){\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = match.getIndex_text() ; i < match.getIndex_text() + match.getToken_Matched_Length() ; i++){\n\t\t\t\tif(Visited_Text[i] == 1){\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag == 1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return false;\n\t\t}\n\t\tint GREEDY:: Jump_To_Next_Unmarked_Token(int pos,int * vis,int Search_Length,string Text_Code){\n\t\t\tint Dist = Dist_To_Next_Tile (pos ,vis ,Search_Length ,Text_Code);\n\t\t\tif( pos + 1 == Text_Code.length()){\n\t\t\t\treturn  0;\n\t\t\t}\n\t\t\tfor(pos += Dist ; pos + 1 < Text_Code.length() && vis[ pos + 1] == 1 ; pos++){}\n\t\t\tif(pos + 1 > Text_Code.length() - 1){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn pos + 1;\n\t\t}\n\t\tlong long int GREEDY::  String_To_Hashvalue(string s ){\n\t\t\tlong long int n = s.length();\n\t\t\tconst long long int a = pow(10,9);\n\t\t\tlong long int val = 0;\n\t\t\tconst int fval = 31;\n\t\t\tlong long int power = 1;\n\t\t\tchar c ='@';\n\t\t\tlong long int e = n - 1;\n\t\t\tfor(int i = 0 ; i < n ; i++){//85-65\n\t\t\t\tval = ( val + ( ( int(s[i] )- int(c) ) *power ) )%(a+9) ;\n\t\t\t\tpower = ( power * fval ) % (a+9); \n\t\t\t}\n\t\t\treturn val; \n\t\t}\n\n\t\tint GREEDY:: Scan_Pattern (int Initial_Search_Length){\n\t\t\tint Maxmatch_Found = 0;\n\t\t\tint Search_Length = Initial_Search_Length;\n\t\t\tint Text_Position = 0;\n\t\t\tpriority_queue < MATCH > Prior_queue;\n\t\t\tbool No_Next_Tile = false;\n\t\t\twhile(Text_Position < Text_Code.length()){\n\t\t\t\tif(Is_Text_Marked( Text_Position ) ){\n\t\t\t\t\tText_Position++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint Dist = Dist_To_Next_Tile(Text_Position,Visited_Text,Search_Length,Text_Code);\n\t\t\t\t\tif(Dist == 0){\n\t\t\t\t\t\tNo_Next_Tile = true;\n\t\t\t\t\t\tDist=Text_Code.length() - Text_Position;\n\t\t\t\t\t}\n\t\t\t\t\tif(Dist < Search_Length){\n\t\t\t\t\t\tif(No_Next_Tile){\n\t\t\t\t\t\t\tText_Position = Text_Code.length();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tText_Position = Jump_To_Next_Unmarked_Token(Text_Position,Visited_Text,Search_Length,Text_Code);\n\t\t\t\t\t\t\tif(Text_Position == 0){\n\t\t\t\t\t\t\t\tText_Position = Text_Code.length();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstring Substring = \"\";\n\t\t\t\t\t\tfor(int i = Text_Position ; i <= Text_Position+Search_Length-1 ; i++){\n\t\t\t\t\t\t\tSubstring = Substring + Text_Code[i];\n\t\t\t\t\t\t\tHashmap.insert({String_To_Hashvalue(Substring),Text_Position});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tText_Position++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint Pattern_Position = 0;\n\t\t\tNo_Next_Tile = false;\n\n\t\t\twhile(Pattern_Position < Pattern_Code.length()){\n\t\t\t\tif(Is_Pattern_Marked(Pattern_Position)){\n\t\t\t\t\tPattern_Position++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint Dist = Dist_To_Next_Tile(Pattern_Position,Visited_Pattern,Search_Length,Pattern_Code);\n\t\t\t\t\tif(Dist == 0){\n\t\t\t\t\t\tNo_Next_Tile = true;\n\t\t\t\t\t\tDist = Pattern_Code.length() - Pattern_Position;\n\t\t\t\t\t}\n\t\t\t\t\tif(Dist < Search_Length){\n\t\t\t\t\t\tif(No_Next_Tile){\n\t\t\t\t\t\t\tPattern_Position = Pattern_Code.length();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tPattern_Position = Jump_To_Next_Unmarked_Token(Pattern_Position,Visited_Pattern,Search_Length,Pattern_Code);\n\t\t\t\t\t\t\tif(Pattern_Position == 0){\n\t\t\t\t\t\t\t\tPattern_Position = Pattern_Code.length();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t\telse{\n\t\t\t\t\t\tstring Substring = \"\";\n\t\t\t\t\t\tfor(int i = Pattern_Position ; i <= Pattern_Position+Search_Length-1 ; i++){\n\t\t\t\t\t\t\tSubstring = Substring + Pattern_Code[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong long int hash1 = String_To_Hashvalue(Substring);\n\t\t\t\t\t\tauto Index_Text = Hashmap.equal_range(hash1);\n\t\t\t\t\t\tvector < int > Occurance;\n\t\t\t\t\t\tfor(auto itr = Index_Text.first ; itr!=Index_Text.second ; itr++){\n\t\t\t\t\t\t\tOccurance.push_back(itr->second);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(Occurance.size() != 0){\n\t\t\t\t\t\t\tfor(int j = 0 ; j < Occurance.size() ; j++ ){\n\t\t\t\t\t\t\t\tint Text_Match_Start = Occurance[j];\n\t\t\t\t\t\t\t\tint Match_Length = 0;\n\t\t\t\t\t\t\t\tstring temp=\"\";\t\t\n\t\t\t\t\t\t\t\twhile(Pattern_Code[Pattern_Position + Match_Length] == Text_Code[Text_Match_Start+Match_Length] && Visited_Pattern[Pattern_Position + Match_Length] == 0 && Visited_Text[Text_Match_Start + Match_Length] == 0){\n\t\t\t\t\t\t\t\t\ttemp = temp + Pattern_Code[Pattern_Position + Match_Length];\n\t\t\t\t\t\t\t\t\tMatch_Length++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(Match_Length > 2 * Search_Length){\n\t\t\t\t\t\t\t\t\tSearch_Length = Match_Length;\t\t\n\t\t\t\t\t\t\t\t\ttemp = \"\";\n\t\t\t\t\t\t\t\t\treturn Match_Length;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(Maxmatch_Found < Search_Length){\n\t\t\t\t\t\t\t\t\tMaxmatch_Found = Search_Length;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(Maxmatch_Found < Match_Length){ \n\t\t\t\t\t\t\t\t\tMaxmatch_Found = Match_Length;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(Match_Length >= Minimum_Matching_length)\n\t\t\t\t\t\t\t\tPrior_queue.push(MATCH(Pattern_Position,Text_Match_Start,Match_Length,temp));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}Pattern_Position++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!Prior_queue.empty()){\n\t\t\t\tMatches_Found.push_back(Prior_queue);\n\t\t\t}\n\t\t\treturn Maxmatch_Found;\n\t\t} \n\t\t\t\n\t\tvoid GREEDY:: Mark_String_Matches (){\n\t\t\tfor(priority_queue<MATCH > Prior_queue:Matches_Found){\n\t\t\t\twhile(!Prior_queue.empty()){\n\t\t\t\t\tMATCH m1 = Prior_queue.top();\n\t\t\t\t\tPrior_queue.pop();\n\t\t\t\t\tif(!isoccluded(m1)){\n\t\t\t\t\t\tfor(int i = 0 ; i < m1.getToken_Matched_Length() - 1 ; i++){\n\t\t\t\t\t\t\tVisited_Pattern[m1.getIndex_Pattern() + i ] = 1 ;\n\t\t\t\t\t\t\tVisited_Text[m1.getIndex_text() + i ]= 1 ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTiles.push_back(m1);\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tMatches_Found.clear();\n\t\t}\n\t\tvoid GREEDY:: Greedy_Rabin_Karp_Driver(){\n\t\t\t int initsearchSize = 20 ;\n\t\t\tif(Minimum_Matching_length < 3){\n\t\t\t\tMinimum_Matching_length = 3;\n\t\t\t}\n\t\t\tbool stop = false;\n\t\t\tint Search_Length = initsearchSize;\n\t\t\twhile(!stop){\n\t\t\t\tint Lmax = Scan_Pattern(Search_Length);\n\t\t\t\tif(Lmax > 2 * Search_Length){\n\t\t\t\t\tSearch_Length = Lmax;\n\t\t\t\t} \n\t\t\t\telse{\n\t\t\t\t\tMark_String_Matches();\n\t\t\t\t\tif(Search_Length > 2* Minimum_Matching_length){\n\t\t\t\t\t\tSearch_Length /= 2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(Search_Length   > Minimum_Matching_length){\n\t\t\t\t\t\tSearch_Length = Minimum_Matching_length;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstop = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool GREEDY::  Is_Pattern_Marked(int pos){\n\t\t\tif(Visited_Pattern[pos] == 1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\tbool GREEDY::  Is_Text_Marked(int pos){\n\t\t\tif(Visited_Text[pos] == 1){\n\t\t\t\treturn true;\n\t\t\t} \n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\tvoid GREEDY:: tiling(){\n\t\t\tfor(int i = 0 ; i < Tiles.size() ; i++){\n\t\t\t\tcout << \"Tiles = \" << Tiles[i].getmatch() << \" \" << \"Index_Pattern  = \" << Tiles[i].getIndex_Pattern() << \" Index_Text = \" << Tiles[i].getIndex_text() << \" length = \" << Tiles[i].getToken _Matched_Length() << endl ;\n\t\t\t}\n\t\t}\n\n\t\tbool operator < (const MATCH &match1, const MATCH &match2){\n\t\t\treturn match1.getToken_Matched_Length() < match2.getToken_Matched_Length();\n\t\t}\n\n\n",
  "name": "GREEDY_Class.cpp"
 },
 {
  "code": "\n\nMATCH :: MATCH(){}\n\n\nMATCH :: MATCH(unsigned long int Index_Pattern,unsigned long int Index_Text,unsigned long int Token_Matched_Length,string m){\n\t\t\tthis->Index_Pattern=Index_Pattern;\n\t\t\tthis->Index_Text=Index_Text;\n\t\t\tthis->Token_Matched_Length=Token_Matched_Length;\n\t\t\tthis->m=m;\n\t\t}\n\nunsigned long int MATCH :: getIndex_Pattern(){\n\t\t\treturn Index_Pattern;\t\n\t\t}\n\nunsigned long int MATCH :: getIndex_Text(){\n\t\t\treturn Index_Text;\n\t\t}\n\nunsigned long int MATCH :: getToken_Matched_Length()const{\n\t\t\treturn Token_Matched_Length;\n\t\t}\n\nunsigned long MATCH :: getmatch(){\n\t\t\treturn m;\n\t\t}\n\n\n\n\n\n\n\n\n\n\n\n",
  "name": "MATCH_Class.cpp"
 },
 {
  "code": "// C++ program to print diamond shape\n// with 2n rows\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Prints diamond pattern with 2n rows\nvoid printDiamond(int n)\n{\n\tint space = n - 1;\n\n\t// run loop (parent loop)\n\t// till number of rows\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0;j < space; j++)\n\t\t\tcout << \" \";\n\n\t\t// Print i+1 stars\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tcout << \"* \";\n\n\t\tcout << endl;\n\t\tspace--;\n\t}\n\n\t// Repeat again in reverse order\n\tspace = 0;\n\n\t// run loop (parent loop)\n\t// till number of rows\n\tfor (int i = n; i > 0; i--)\n\t{\n\t\t// loop for initially space,\n\t\t// before star printing\n\t\tfor (int j = 0; j < space; j++)\n\t\t\tcout << \" \";\n\n\t\t// Print i stars\n\t\tfor (int j = 0;j < i;j++)\n\t\t\tcout << \"* \";\n\n\t\tcout << endl;\n\t\tspace++;\n\t}\n\tspace = n - 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\t// loop for initially space,\n\t\t// before star printing\n\t\tfor (int j = 0;j < space; j++)\n\t\t\tcout << \" \";\n\n\t\t// Print i+1 stars\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tcout << \"* \";\n\n\t\tcout << endl;\n\t\tspace--;\n\t}\n\n\t// Repeat again in reverse order\n\tspace = 0;\n\n\t// run loop (parent loop)\n\t// till number of rows\n\tfor (int i = n; i > 0; i--)\n\t{\n\t\t// loop for initially space,\n\t\t// before star printing\n\t\tfor (int j = 0; j < space; j++)\n\t\t\tcout << \" \";\n\n\t\t// Print i stars\n\t\tfor (int j = 0;j < i;j++)\n\t\t\tcout << \"* \";\n\n\t\tcout << endl;\n\t\tspace++;\n\t}\n}\n\n// Driver code\nint main()\n{\n\tprintDiamond(5);\n\treturn 0;\n\n\n// This is code is contributed\n// by rathbhupendra\n\n}\n",
  "name": "foorloop - Copy.cpp"
 },
 {
  "code": "// C++ program to print diamond shape\n// with 2n rows\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Prints diamond pattern with 2n rows\nvoid printDiamond(int n)\n{\n\tint space = n - 1;\n\n\t// run loop (parent loop)\n\t// till number of rows\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0;j < space; j++)\n\t\t\tcout << \" \";\n\n\t\t// Print i+1 stars\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tcout << \"* \";\n\n\t\tcout << endl;\n\t\tspace--;\n\t}\n\n\t// Repeat again in reverse order\n\tspace = 0;\n\n\t// run loop (parent loop)\n\t// till number of rows\n\tfor (int i = n; i > 0; i--)\n\t{\n\t\t// loop for initially space,\n\t\t// before star printing\n\t\tfor (int j = 0; j < space; j++)\n\t\t\tcout << \" \";\n\n\t\t// Print i stars\n\t\tfor (int j = 0;j < i;j++)\n\t\t\tcout << \"* \";\n\n\t\tcout << endl;\n\t\tspace++;\n\t}\n\tspace = n - 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\t// loop for initially space,\n\t\t// before star printing\n\t\tfor (int j = 0;j < space; j++)\n\t\t\tcout << \" \";\n\n\t\t// Print i+1 stars\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tcout << \"* \";\n\n\t\tcout << endl;\n\t\tspace--;\n\t}\n\n\t// Repeat again in reverse order\n\tspace = 0;\n\n\t// run loop (parent loop)\n\t// till number of rows\n\tfor (int i = n; i > 0; i--)\n\t{\n\t\t// loop for initially space,\n\t\t// before star printing\n\t\tfor (int j = 0; j < space; j++)\n\t\t\tcout << \" \";\n\n\t\t// Print i stars\n\t\tfor (int j = 0;j < i;j++)\n\t\t\tcout << \"* \";\n\n\t\tcout << endl;\n\t\tspace++;\n\t}\n}\n\n// Driver code\nint main()\n{\n\tprintDiamond(5);\n\treturn 0;\n\n\n// This is code is contributed\n// by rathbhupendra\n\n}\n",
  "name": "foorloop.cpp"
 },
 {
  "code": "#include <iostream>\n#include <regex>\n#include <unordered_set>\n#include<set>\n#include<cmath>\n#include<map>\n#include<bits/stdc++.h>\n#include <fstream>\n#include <unordered_map>\n#include <vector>\n#include <dirent.h>\nusing namespace std;\n\n\nclass TOKEN\n{\n    string Token_Type; //TPYE OF TOKEN\n    string Token_Content; //CONTENT OF TOKEN\n    unsigned long int Token_Start_Line_no; // START LINE NO OF THE TOKEN IN THE CODE\n    unsigned long int Token_End_Line_no; //END LINE NO OF THE CODE\n    unsigned long int Token_Start_Pos; //START POSITION OF THE TOKEN IN THE CODE STRING\n    unsigned long int Token_End_Pos; //END POSITION OF THE TOKEN IN THE CODE STRING\n\npublic:\n    /*TOKEN INITIALIZATION CONSTRUCTOR*/\n    TOKEN()\n    {\n        Token_Type = \"\";\n        Token_Content = \"\";\n        Token_Start_Line_no = 0;\n        Token_End_Line_no = 0;\n        Token_Start_Pos =0;\n        Token_End_Pos = 0;\n    }\n\npublic:\n    void setToken_Type(string Token_Type);\n    void setToken_Content(string Token_Content);\n    void setToken_Start_Line_no(unsigned long int Token_Start_Line_no);\n    void setToken_End_Line_no(unsigned long int Token_End_Line_no);\n    void setTokenPos(unsigned long int Token_Start_Pos, unsigned long int Token_End_Pos);\n    void setToken_Line_no(unsigned long int Token_Start_Line_no, unsigned long int Token_End_Line_no);\n\n    string getToken_Type();\n    string getToken_Content();\n    unsigned long int getToken_Start_Line_no();\n    unsigned long int getToken_End_Line_no();\n    unsigned long int getToken_Start_Pos();\n    unsigned long int getToken_End_Pos();\n\n};\n\n\n\n\nclass TOKENIZER\n{\n    string Source_File_Name; // SOURCE CODE FILE NAME\n    string Normalized_Source_File_Code; // NORMALIZED SOURCE CODE FILE\n    string Original_Source_File_Code; // ORIGINAL SOURCE CODE FILE\n    string Source_File_Path; // PATH OF THE SOURCE FILE\n    string Source_File_Language;\n    map <unsigned long int, TOKEN> Tokenized_File; // TOKENIZED FILE MAP TO SAVE ALL DATA OF GENERATED TOKENS\n    vector<TOKEN> Tokenized_File_Vector;\n    string Source_File_Token;\n\npublic:\n\t\n    TOKENIZER();\n    TOKENIZER( string Source_File_Language, string Source_File_Path, string Source_File_Name );\n    string getSource_File_Name();\n    string getSource_File_Language();\n    string getOriginal_Source_File_Code();\n    string getNormalized_Source_File_Code();   \n    string getSource_File_Path();    \n    void getData();\n    TOKEN getTokenized_File_Vector(unsigned long int index);\n    string getSource_File_Token();\n   \n};\n\nbool isPathValid(string FolderPath);\nbool isEmpty_Dir_File(string FolderPath, string Source_File_Name);\nbool CreateTokens( string FolderPath, vector <TOKENIZER> & Folder_Files);\n\n\n#include \"REGEX_DEFN.cpp\"\n#include \"TOKEN_Class.cpp\"\n#include \"TOKENIZER_Class.cpp\"\n#include \"FUNCTIONS.cpp\"\n\n\n/*Greedy String Algo */\n\nclass MATCH\n{\n\n\t\tunsigned long int Index_Pattern;\n\t\tunsigned long int Index_Text;\n\t\tunsigned long int Token_Matched_Length;\n\t\tstring m;\n\tpublic:\n\t\tMATCH();\n\t\tMATCH(unsigned long int Index_Pattern,unsigned long int Index_Text,unsigned long int Token_Matched_Length,string m);\n\t\tunsigned long int getIndex_Pattern();\n\t\tunsigned long int getIndex_Text();\n\t\tunsigned long int getToken_Matched_Length()const;\n\t\tstring getmatch();\n};\n\n\nbool operator < (const MATCH &match1, const MATCH &match2);\n\n\n\nclass GREEDY\n{\n\n        string Pattern_Code;\n        string Text_Code;\n        int Minimum_Matching_length;\n        int *Visited_Pattern;\n        int *Visited_Text;\n        vector < priority_queue< MATCH > > Matches_Found;\n        vector < MATCH > Tiles;\n        multimap < long long int,int > Hashmap;//hashtable for storing multiple hash-values \n    public:\n        GREEDY();\n        GREEDY(string Pattern_Code,string Text_Code,int  Minimum_Matching_length);\n        int Dist_To_Next_Tile(int pos,int *vis,int Search_Length,string Code);\n        bool isoccluded(MATCH match);\n        int Jump_To_Next_Unmarked_Token(int pos,int * vis,int Search_Length,string Text_Code);\n        long long int String_To_Hashvalue(string s );\n        int Scan_Pattern (int Initial_Search_Length);\n        void Mark_String_Matches ();\n        void Greedy_Rabin_Karp_Driver();\n        bool Is_Pattern_Marked(int pos);\n        bool Is_Text_Marked(int pos);\n        bool tiling();\n\n};\n#include \"MATCH_Class.cpp\"\n#include \"GREEDY_Class.cpp\"\n",
  "name": "header - Copy.cpp"
 },
 {
  "code": "#include <iostream>\n#include <regex>\n#include <unordered_set>\n#include<set>\n#include<cmath>\n#include<map>\n#include<bits/stdc++.h>\n#include <fstream>\n#include <unordered_map>\n#include <vector>\n#include <dirent.h>\nusing namespace std;\n\n\nclass TOKEN\n{\n    string Token_Type; //TPYE OF TOKEN\n    string Token_Content; //CONTENT OF TOKEN\n    unsigned long int Token_Start_Line_no; // START LINE NO OF THE TOKEN IN THE CODE\n    unsigned long int Token_End_Line_no; //END LINE NO OF THE CODE\n    unsigned long int Token_Start_Pos; //START POSITION OF THE TOKEN IN THE CODE STRING\n    unsigned long int Token_End_Pos; //END POSITION OF THE TOKEN IN THE CODE STRING\n\npublic:\n    /*TOKEN INITIALIZATION CONSTRUCTOR*/\n    TOKEN()\n    {\n        Token_Type = \"\";\n        Token_Content = \"\";\n        Token_Start_Line_no = 0;\n        Token_End_Line_no = 0;\n        Token_Start_Pos =0;\n        Token_End_Pos = 0;\n    }\n\npublic:\n    void setToken_Type(string Token_Type);\n    void setToken_Content(string Token_Content);\n    void setToken_Start_Line_no(unsigned long int Token_Start_Line_no);\n    void setToken_End_Line_no(unsigned long int Token_End_Line_no);\n    void setTokenPos(unsigned long int Token_Start_Pos, unsigned long int Token_End_Pos);\n    void setToken_Line_no(unsigned long int Token_Start_Line_no, unsigned long int Token_End_Line_no);\n\n    string getToken_Type();\n    string getToken_Content();\n    unsigned long int getToken_Start_Line_no();\n    unsigned long int getToken_End_Line_no();\n    unsigned long int getToken_Start_Pos();\n    unsigned long int getToken_End_Pos();\n\n};\n\n\n\n\nclass TOKENIZER\n{\n    string Source_File_Name; // SOURCE CODE FILE NAME\n    string Normalized_Source_File_Code; // NORMALIZED SOURCE CODE FILE\n    string Original_Source_File_Code; // ORIGINAL SOURCE CODE FILE\n    string Source_File_Path; // PATH OF THE SOURCE FILE\n    string Source_File_Language;\n    map <unsigned long int, TOKEN> Tokenized_File; // TOKENIZED FILE MAP TO SAVE ALL DATA OF GENERATED TOKENS\n    vector<TOKEN> Tokenized_File_Vector;\n    string Source_File_Token;\n\npublic:\n\t\n    TOKENIZER();\n    TOKENIZER( string Source_File_Language, string Source_File_Path, string Source_File_Name );\n    string getSource_File_Name();\n    string getSource_File_Language();\n    string getOriginal_Source_File_Code();\n    string getNormalized_Source_File_Code();   \n    string getSource_File_Path();    \n    void getData();\n    TOKEN getTokenized_File_Vector(unsigned long int index);\n    string getSource_File_Token();\n   \n};\n\nbool isPathValid(string FolderPath);\nbool isEmpty_Dir_File(string FolderPath, string Source_File_Name);\nbool CreateTokens( string FolderPath, vector <TOKENIZER> & Folder_Files);\n\n\n#include \"REGEX_DEFN.cpp\"\n#include \"TOKEN_Class.cpp\"\n#include \"TOKENIZER_Class.cpp\"\n#include \"FUNCTIONS.cpp\"\n\n\n/*Greedy String Algo */\n\nclass MATCH\n{\n\n\t\tunsigned long int Index_Pattern;\n\t\tunsigned long int Index_Text;\n\t\tunsigned long int Token_Matched_Length;\n\t\tstring m;\n\tpublic:\n\t\tMATCH();\n\t\tMATCH(unsigned long int Index_Pattern,unsigned long int Index_Text,unsigned long int Token_Matched_Length,string m);\n\t\tunsigned long int getIndex_Pattern();\n\t\tunsigned long int getIndex_Text();\n\t\tunsigned long int getToken_Matched_Length()const;\n\t\tstring getmatch();\n};\n\n\nbool operator < (const MATCH &match1, const MATCH &match2);\n\n\n\nclass GREEDY\n{\n\n        string Pattern_Code;\n        string Text_Code;\n        int Minimum_Matching_length;\n        int *Visited_Pattern;\n        int *Visited_Text;\n        vector < priority_queue< MATCH > > Matches_Found;\n        vector < MATCH > Tiles;\n        multimap < long long int,int > Hashmap;//hashtable for storing multiple hash-values \n    public:\n        GREEDY();\n        GREEDY(string Pattern_Code,string Text_Code,int  Minimum_Matching_length);\n        int Dist_To_Next_Tile(int pos,int *vis,int Search_Length,string Code);\n        bool isoccluded(MATCH match);\n        int Jump_To_Next_Unmarked_Token(int pos,int * vis,int Search_Length,string Text_Code);\n        long long int String_To_Hashvalue(string s );\n        int Scan_Pattern (int Initial_Search_Length);\n        void Mark_String_Matches ();\n        void Greedy_Rabin_Karp_Driver();\n        bool Is_Pattern_Marked(int pos);\n        bool Is_Text_Marked(int pos);\n        bool tiling();\n\n};\n#include \"MATCH_Class.cpp\"\n#include \"GREEDY_Class.cpp\"\n",
  "name": "header.cpp"
 },
 {
  "code": "#include \"header.cpp\"\n\n//ADD FOLLOWING LINES AS ARGUMENTS OF MAIN IF PATH IS TO BE GIVEN FROM COMMAND PROMPT\n//*int argc, char* argv[]\n//class Main{\n\n    vector <TOKENIZER> Folder_Files;\n    vector <MATCHER> ALL_MATCHES;\n//public:\n\n    //Main(){}\n\n//};\n\nvoid threading(int i,int j,int Minimum_Matching_length){\n\n        GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n        g1.Greedy_Rabin_Karp_Driver();\n        //g1.tiling();\n\n        MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n        ALL_MATCHES.push_back(m1);\n}\nint main(int argc, char* argv[])\n{\n    string FolderPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\plag_pro\\\\latest-submission\";   //   E:\\Plagirism_Project\\MODULAR_CODE\\Testing\\DS-EXAM 1 TREE REPLACE with argv[2];E:\\Plagirism_Project\\MODULAR_CODE\\Testing\n    string ResultPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\plag_pro\\\\result\";\n    //vector <TOKENIZER> Folder_Files; // VECTOR TO STORE ALL DATA OF FILES //Folder_Files[0].;\n    string Language = \"c/c++\" ;  // REPLACE with argv[1];\n    //vector <MATCHER> ALL_MATCHES;\n    set<string> All_Languages { \"c/c++\", \"java\", \"python\" };\n    int Minimum_Matching_length = 4;\n    cout<<\"***Measure of Software Plagiarism***\" << endl << endl;\n    try\n    {\n        if(!isLanguageValid(Language, All_Languages))\n            throw  \"Error: Invalid Language!\";\n\n        if(!isPathValid(FolderPath))\n            throw  \"Error: Source Directory Not Found!\";\n\n        if(!isPathValid(ResultPath))\n            throw  \"Error: Result Directory Not Found!\";\n\n        if(!CreateTokens(Language, FolderPath, Folder_Files))\n            throw  \"Error: Directory does not have enough valid files to compare!\";\n    }\n\n    catch(const char* Error)\n    {\n        cout<<Error<<endl;\n        string  sERROR = Error;\n        if(sERROR == \"Error: Invalid Language!\")\n        {\n            cout<<\"Languages should be one of these: \";\n            for (auto itarg = All_Languages.begin(); itarg != All_Languages.end(); itarg++)\n                cout << *itarg << \",   \";\n            cout << endl;\n        }\n\n        return 0;\n    }\n\n\n    cout <<\"sensitivity:  \" << Minimum_Matching_length << endl;\n    int counter =0;\n    if(Folder_Files.size() <=1)\n        return 0;\n\n    vector<thread> threads;\n\n    for (unsigned long int i = 0; i < Folder_Files.size()-1 ; i++ )\n    {\n        for( unsigned long int j = i+1; j < Folder_Files.size(); j++)\n        {\n            /*GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n            g1.Greedy_Rabin_Karp_Driver();\n            //g1.tiling();\n\n            MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n            ALL_MATCHES.push_back(m1);*/\n           //  cout << endl << endl;\n\n          // threads.push_back(thread(threading,i,j,Minimum_Matching_length));\n           thread th1(threading,i,j,Minimum_Matching_length);\n           th1.join ();\n            //counter++;\n            //cout << counter << endl;\n        }\n\n        /*for (auto &th : threads) {\n        th.join();\n        }*/\n    }\n\n\n    cout << endl << \"Total Compared Pairs:  \" << ALL_MATCHES.size() << endl << endl;\n   // sort(ALL_MATCHES.begin(), ALL_MATCHES.end(), compare_Matches_percentage );\n\n    for(unsigned long int i = 0; i < ALL_MATCHES.size(); i++)\n    {\n        cout << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_1()].getSource_File_Name()\n             << \"   \"\n             << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_2()].getSource_File_Name();\n        cout << \"   Percent 1: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_1());\n        cout << \"   Percent 2: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_2());\n        cout << endl;\n    }\n\n\n    createJSON(ResultPath, Folder_Files, ALL_MATCHES);\n   //  createHTML(ResultPath, Folder_Files, ALL_MATCHES);\n    //createTokensHTML(ResultPath, Folder_Files, ALL_MATCHES);\n\n    return 0;\n}\n",
  "name": "main (1) - Copy - Copy.cpp"
 },
 {
  "code": "#include \"header.cpp\"\n\n//ADD FOLLOWING LINES AS ARGUMENTS OF MAIN IF PATH IS TO BE GIVEN FROM COMMAND PROMPT\n//*int argc, char* argv[]\n//class Main{\n\n    vector <TOKENIZER> Folder_Files;\n    vector <MATCHER> ALL_MATCHES;\n//public:\n\n    //Main(){}\n\n//};\n\nvoid threading(int i,int j,int Minimum_Matching_length){\n\n        GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n        g1.Greedy_Rabin_Karp_Driver();\n        //g1.tiling();\n\n        MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n        ALL_MATCHES.push_back(m1);\n}\nint main(int argc, char* argv[])\n{\n    string FolderPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\plag_pro\\\\latest-submission\";   //   E:\\Plagirism_Project\\MODULAR_CODE\\Testing\\DS-EXAM 1 TREE REPLACE with argv[2];E:\\Plagirism_Project\\MODULAR_CODE\\Testing\n    string ResultPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\plag_pro\\\\result\";\n    //vector <TOKENIZER> Folder_Files; // VECTOR TO STORE ALL DATA OF FILES //Folder_Files[0].;\n    string Language = \"c/c++\" ;  // REPLACE with argv[1];\n    //vector <MATCHER> ALL_MATCHES;\n    set<string> All_Languages { \"c/c++\", \"java\", \"python\" };\n    int Minimum_Matching_length = 4;\n    cout<<\"***Measure of Software Plagiarism***\" << endl << endl;\n    try\n    {\n        if(!isLanguageValid(Language, All_Languages))\n            throw  \"Error: Invalid Language!\";\n\n        if(!isPathValid(FolderPath))\n            throw  \"Error: Source Directory Not Found!\";\n\n        if(!isPathValid(ResultPath))\n            throw  \"Error: Result Directory Not Found!\";\n\n        if(!CreateTokens(Language, FolderPath, Folder_Files))\n            throw  \"Error: Directory does not have enough valid files to compare!\";\n    }\n\n    catch(const char* Error)\n    {\n        cout<<Error<<endl;\n        string  sERROR = Error;\n        if(sERROR == \"Error: Invalid Language!\")\n        {\n            cout<<\"Languages should be one of these: \";\n            for (auto itarg = All_Languages.begin(); itarg != All_Languages.end(); itarg++)\n                cout << *itarg << \",   \";\n            cout << endl;\n        }\n\n        return 0;\n    }\n\n\n    cout <<\"sensitivity:  \" << Minimum_Matching_length << endl;\n    int counter =0;\n    if(Folder_Files.size() <=1)\n        return 0;\n\n    vector<thread> threads;\n\n    for (unsigned long int i = 0; i < Folder_Files.size()-1 ; i++ )\n    {\n        for( unsigned long int j = i+1; j < Folder_Files.size(); j++)\n        {\n            /*GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n            g1.Greedy_Rabin_Karp_Driver();\n            //g1.tiling();\n\n            MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n            ALL_MATCHES.push_back(m1);*/\n           //  cout << endl << endl;\n\n          // threads.push_back(thread(threading,i,j,Minimum_Matching_length));\n           thread th1(threading,i,j,Minimum_Matching_length);\n           th1.join ();\n            //counter++;\n            //cout << counter << endl;\n        }\n\n        /*for (auto &th : threads) {\n        th.join();\n        }*/\n    }\n\n\n    cout << endl << \"Total Compared Pairs:  \" << ALL_MATCHES.size() << endl << endl;\n   // sort(ALL_MATCHES.begin(), ALL_MATCHES.end(), compare_Matches_percentage );\n\n    for(unsigned long int i = 0; i < ALL_MATCHES.size(); i++)\n    {\n        cout << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_1()].getSource_File_Name()\n             << \"   \"\n             << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_2()].getSource_File_Name();\n        cout << \"   Percent 1: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_1());\n        cout << \"   Percent 2: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_2());\n        cout << endl;\n    }\n\n\n    createJSON(ResultPath, Folder_Files, ALL_MATCHES);\n   //  createHTML(ResultPath, Folder_Files, ALL_MATCHES);\n    //createTokensHTML(ResultPath, Folder_Files, ALL_MATCHES);\n\n    return 0;\n}\n",
  "name": "main (1) - Copy.cpp"
 },
 {
  "code": "#include \"header.cpp\"\n\n//ADD FOLLOWING LINES AS ARGUMENTS OF MAIN IF PATH IS TO BE GIVEN FROM COMMAND PROMPT\n//*int argc, char* argv[]\n//class Main{\n\n    vector <TOKENIZER> Folder_Files;\n    vector <MATCHER> ALL_MATCHES;\n//public:\n\n    //Main(){}\n\n//};\n\nvoid threading(int i,int j,int Minimum_Matching_length){\n\n        GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n        g1.Greedy_Rabin_Karp_Driver();\n        //g1.tiling();\n\n        MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n        ALL_MATCHES.push_back(m1);\n}\nint main(int argc, char* argv[])\n{\n    string FolderPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\plag_pro\\\\latest-submission\";   //   E:\\Plagirism_Project\\MODULAR_CODE\\Testing\\DS-EXAM 1 TREE REPLACE with argv[2];E:\\Plagirism_Project\\MODULAR_CODE\\Testing\n    string ResultPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\plag_pro\\\\result\";\n    //vector <TOKENIZER> Folder_Files; // VECTOR TO STORE ALL DATA OF FILES //Folder_Files[0].;\n    string Language = \"c/c++\" ;  // REPLACE with argv[1];\n    //vector <MATCHER> ALL_MATCHES;\n    set<string> All_Languages { \"c/c++\", \"java\", \"python\" };\n    int Minimum_Matching_length = 4;\n    cout<<\"***Measure of Software Plagiarism***\" << endl << endl;\n    try\n    {\n        if(!isLanguageValid(Language, All_Languages))\n            throw  \"Error: Invalid Language!\";\n\n        if(!isPathValid(FolderPath))\n            throw  \"Error: Source Directory Not Found!\";\n\n        if(!isPathValid(ResultPath))\n            throw  \"Error: Result Directory Not Found!\";\n\n        if(!CreateTokens(Language, FolderPath, Folder_Files))\n            throw  \"Error: Directory does not have enough valid files to compare!\";\n    }\n\n    catch(const char* Error)\n    {\n        cout<<Error<<endl;\n        string  sERROR = Error;\n        if(sERROR == \"Error: Invalid Language!\")\n        {\n            cout<<\"Languages should be one of these: \";\n            for (auto itarg = All_Languages.begin(); itarg != All_Languages.end(); itarg++)\n                cout << *itarg << \",   \";\n            cout << endl;\n        }\n\n        return 0;\n    }\n\n\n    cout <<\"sensitivity:  \" << Minimum_Matching_length << endl;\n    int counter =0;\n    if(Folder_Files.size() <=1)\n        return 0;\n\n    vector<thread> threads;\n\n    for (unsigned long int i = 0; i < Folder_Files.size()-1 ; i++ )\n    {\n        for( unsigned long int j = i+1; j < Folder_Files.size(); j++)\n        {\n            /*GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n            g1.Greedy_Rabin_Karp_Driver();\n            //g1.tiling();\n\n            MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n            ALL_MATCHES.push_back(m1);*/\n           //  cout << endl << endl;\n\n          // threads.push_back(thread(threading,i,j,Minimum_Matching_length));\n           thread th1(threading,i,j,Minimum_Matching_length);\n           th1.join ();\n            //counter++;\n            //cout << counter << endl;\n        }\n\n        /*for (auto &th : threads) {\n        th.join();\n        }*/\n    }\n\n\n    cout << endl << \"Total Compared Pairs:  \" << ALL_MATCHES.size() << endl << endl;\n   // sort(ALL_MATCHES.begin(), ALL_MATCHES.end(), compare_Matches_percentage );\n\n    for(unsigned long int i = 0; i < ALL_MATCHES.size(); i++)\n    {\n        cout << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_1()].getSource_File_Name()\n             << \"   \"\n             << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_2()].getSource_File_Name();\n        cout << \"   Percent 1: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_1());\n        cout << \"   Percent 2: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_2());\n        cout << endl;\n    }\n\n\n    createJSON(ResultPath, Folder_Files, ALL_MATCHES);\n   //  createHTML(ResultPath, Folder_Files, ALL_MATCHES);\n    //createTokensHTML(ResultPath, Folder_Files, ALL_MATCHES);\n\n    return 0;\n}\n",
  "name": "main (1).cpp"
 },
 {
  "code": "#include \"header.cpp\"\n#include <thread>\n//ADD FOLLOWING LINES AS ARGUMENTS OF MAIN IF PATH IS TO BE GIVEN FROM COMMAND PROMPT\n//*int argc, char* argv[]\n\n\nvector <TOKENIZER> Folder_Files;\n\n vector <MATCHER> ALL_MATCHES;\n\n vector <thread>Threads;\n\n int counter=0;\nvoid threading(int i,int j,int Minimum_Matching_length){\n\n    GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n    g1.Greedy_Rabin_Karp_Driver();\n    //g1.tiling();\n\n    MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n    ALL_MATCHES.push_back(m1);\n\n    cout << counter++ <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n}\nint main(int argc, char* argv[])\n{\n    //C:\\Users\\user\\Desktop\\Plag_Project\\newPlag\\LAXMAN_PLAG\\testing\n    string FolderPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\testing\";   //   E:\\Plagirism_Project\\MODULAR_CODE\\Testing\\DS-EXAM 1 TREE REPLACE with argv[2];E:\\Plagirism_Project\\MODULAR_CODE\\Testing\n    string ResultPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\result\";\n    //vector <TOKENIZER> Folder_Files; // VECTOR TO STORE ALL DATA OF FILES //Folder_Files[0].;\n    string Language = \"c/c++\" ;  // REPLACE with argv[1];\n    //vector <MATCHER> ALL_MATCHES;\n    set<string> All_Languages { \"c/c++\", \"java\", \"python\" };\n    int Minimum_Matching_length = 5;\n    cout<<\"***Measure of Software Plagiarism***\" << endl << endl;\n    try\n    {\n        if(!isLanguageValid(Language, All_Languages))\n            throw  \"Error: Invalid Language!\";\n\n        if(!isPathValid(FolderPath))\n            throw  \"Error: Source Directory Not Found!\";\n\n        if(!isPathValid(ResultPath))\n            throw  \"Error: Result Directory Not Found!\";\n\n        if(!CreateTokens(Language, FolderPath, Folder_Files))\n            throw  \"Error: Directory does not have enough valid files to compare!\";\n    }\n\n    catch(const char* Error)\n    {\n        cout<<Error<<endl;\n        string  sERROR = Error;\n        if(sERROR == \"Error: Invalid Language!\")\n        {\n            cout<<\"Languages should be one of these: \";\n            for (auto itarg = All_Languages.begin(); itarg != All_Languages.end(); itarg++)\n                cout << *itarg << \",   \";\n            cout << endl;\n        }\n\n        return 0;\n    }\n\n\n    cout <<\"sensitivity:  \" << Minimum_Matching_length << endl;\n    int counter =0;\n    if(Folder_Files.size() <=1)\n        return 0;\n\n    for (unsigned long int i = 0; i < Folder_Files.size()-1 ; i++ )\n    {\n        for( unsigned long int j = i+1; j < Folder_Files.size(); j++)\n        {\n            /*GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n            g1.Greedy_Rabin_Karp_Driver();\n            //g1.tiling();\n\n            MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n            ALL_MATCHES.push_back(m1);*/\n           //  cout << endl << endl;\n\n           Threads.push_back(thread(threading,i,j,Minimum_Matching_length));\n            //counter++;\n            cout << counter <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n        }\n\n\n    }\n\n    for(int i=0;i<Threads.size();i++){\n\n        Threads[i].join();\n    }\n    cout << endl << \"Total Compared Pairs:  \" << ALL_MATCHES.size() << endl << endl;\n    sort(ALL_MATCHES.begin(), ALL_MATCHES.end(), compare_Matches_percentage );\n\n    for(unsigned long int i = 0; i < ALL_MATCHES.size(); i++)\n    {\n        cout << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_1()].getSource_File_Name()\n             << \"   \"\n             << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_2()].getSource_File_Name();\n        cout << \"   Percent 1: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_1());\n        cout << \"   Percent 2: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_2());\n        cout << endl;\n    }\n\n\n    createJSON(ResultPath, Folder_Files, ALL_MATCHES);\n   //  createHTML(ResultPath, Folder_Files, ALL_MATCHES);\n    //createTokensHTML(ResultPath, Folder_Files, ALL_MATCHES);\n\n    return 0;\n}\n",
  "name": "main (2) - Copy - Copy.cpp"
 },
 {
  "code": "#include \"header.cpp\"\n#include <thread>\n//ADD FOLLOWING LINES AS ARGUMENTS OF MAIN IF PATH IS TO BE GIVEN FROM COMMAND PROMPT\n//*int argc, char* argv[]\n\n\nvector <TOKENIZER> Folder_Files;\n\n vector <MATCHER> ALL_MATCHES;\n\n vector <thread>Threads;\n\n int counter=0;\nvoid threading(int i,int j,int Minimum_Matching_length){\n\n    GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n    g1.Greedy_Rabin_Karp_Driver();\n    //g1.tiling();\n\n    MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n    ALL_MATCHES.push_back(m1);\n\n    cout << counter++ <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n}\nint main(int argc, char* argv[])\n{\n    //C:\\Users\\user\\Desktop\\Plag_Project\\newPlag\\LAXMAN_PLAG\\testing\n    string FolderPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\testing\";   //   E:\\Plagirism_Project\\MODULAR_CODE\\Testing\\DS-EXAM 1 TREE REPLACE with argv[2];E:\\Plagirism_Project\\MODULAR_CODE\\Testing\n    string ResultPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\result\";\n    //vector <TOKENIZER> Folder_Files; // VECTOR TO STORE ALL DATA OF FILES //Folder_Files[0].;\n    string Language = \"c/c++\" ;  // REPLACE with argv[1];\n    //vector <MATCHER> ALL_MATCHES;\n    set<string> All_Languages { \"c/c++\", \"java\", \"python\" };\n    int Minimum_Matching_length = 5;\n    cout<<\"***Measure of Software Plagiarism***\" << endl << endl;\n    try\n    {\n        if(!isLanguageValid(Language, All_Languages))\n            throw  \"Error: Invalid Language!\";\n\n        if(!isPathValid(FolderPath))\n            throw  \"Error: Source Directory Not Found!\";\n\n        if(!isPathValid(ResultPath))\n            throw  \"Error: Result Directory Not Found!\";\n\n        if(!CreateTokens(Language, FolderPath, Folder_Files))\n            throw  \"Error: Directory does not have enough valid files to compare!\";\n    }\n\n    catch(const char* Error)\n    {\n        cout<<Error<<endl;\n        string  sERROR = Error;\n        if(sERROR == \"Error: Invalid Language!\")\n        {\n            cout<<\"Languages should be one of these: \";\n            for (auto itarg = All_Languages.begin(); itarg != All_Languages.end(); itarg++)\n                cout << *itarg << \",   \";\n            cout << endl;\n        }\n\n        return 0;\n    }\n\n\n    cout <<\"sensitivity:  \" << Minimum_Matching_length << endl;\n    int counter =0;\n    if(Folder_Files.size() <=1)\n        return 0;\n\n    for (unsigned long int i = 0; i < Folder_Files.size()-1 ; i++ )\n    {\n        for( unsigned long int j = i+1; j < Folder_Files.size(); j++)\n        {\n            /*GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n            g1.Greedy_Rabin_Karp_Driver();\n            //g1.tiling();\n\n            MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n            ALL_MATCHES.push_back(m1);*/\n           //  cout << endl << endl;\n\n           Threads.push_back(thread(threading,i,j,Minimum_Matching_length));\n            //counter++;\n            cout << counter <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n        }\n\n\n    }\n\n    for(int i=0;i<Threads.size();i++){\n\n        Threads[i].join();\n    }\n    cout << endl << \"Total Compared Pairs:  \" << ALL_MATCHES.size() << endl << endl;\n    sort(ALL_MATCHES.begin(), ALL_MATCHES.end(), compare_Matches_percentage );\n\n    for(unsigned long int i = 0; i < ALL_MATCHES.size(); i++)\n    {\n        cout << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_1()].getSource_File_Name()\n             << \"   \"\n             << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_2()].getSource_File_Name();\n        cout << \"   Percent 1: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_1());\n        cout << \"   Percent 2: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_2());\n        cout << endl;\n    }\n\n\n    createJSON(ResultPath, Folder_Files, ALL_MATCHES);\n   //  createHTML(ResultPath, Folder_Files, ALL_MATCHES);\n    //createTokensHTML(ResultPath, Folder_Files, ALL_MATCHES);\n\n    return 0;\n}\n",
  "name": "main (2) - Copy.cpp"
 },
 {
  "code": "#include \"header.cpp\"\n#include <thread>\n//ADD FOLLOWING LINES AS ARGUMENTS OF MAIN IF PATH IS TO BE GIVEN FROM COMMAND PROMPT\n//*int argc, char* argv[]\n\n\nvector <TOKENIZER> Folder_Files;\n\n vector <MATCHER> ALL_MATCHES;\n\n vector <thread>Threads;\n\n int counter=0;\nvoid threading(int i,int j,int Minimum_Matching_length){\n\n    GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n    g1.Greedy_Rabin_Karp_Driver();\n    //g1.tiling();\n\n    MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n    ALL_MATCHES.push_back(m1);\n\n    cout << counter++ <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n}\nint main(int argc, char* argv[])\n{\n    //C:\\Users\\user\\Desktop\\Plag_Project\\newPlag\\LAXMAN_PLAG\\testing\n    string FolderPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\testing\";   //   E:\\Plagirism_Project\\MODULAR_CODE\\Testing\\DS-EXAM 1 TREE REPLACE with argv[2];E:\\Plagirism_Project\\MODULAR_CODE\\Testing\n    string ResultPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\result\";\n    //vector <TOKENIZER> Folder_Files; // VECTOR TO STORE ALL DATA OF FILES //Folder_Files[0].;\n    string Language = \"c/c++\" ;  // REPLACE with argv[1];\n    //vector <MATCHER> ALL_MATCHES;\n    set<string> All_Languages { \"c/c++\", \"java\", \"python\" };\n    int Minimum_Matching_length = 5;\n    cout<<\"***Measure of Software Plagiarism***\" << endl << endl;\n    try\n    {\n        if(!isLanguageValid(Language, All_Languages))\n            throw  \"Error: Invalid Language!\";\n\n        if(!isPathValid(FolderPath))\n            throw  \"Error: Source Directory Not Found!\";\n\n        if(!isPathValid(ResultPath))\n            throw  \"Error: Result Directory Not Found!\";\n\n        if(!CreateTokens(Language, FolderPath, Folder_Files))\n            throw  \"Error: Directory does not have enough valid files to compare!\";\n    }\n\n    catch(const char* Error)\n    {\n        cout<<Error<<endl;\n        string  sERROR = Error;\n        if(sERROR == \"Error: Invalid Language!\")\n        {\n            cout<<\"Languages should be one of these: \";\n            for (auto itarg = All_Languages.begin(); itarg != All_Languages.end(); itarg++)\n                cout << *itarg << \",   \";\n            cout << endl;\n        }\n\n        return 0;\n    }\n\n\n    cout <<\"sensitivity:  \" << Minimum_Matching_length << endl;\n    int counter =0;\n    if(Folder_Files.size() <=1)\n        return 0;\n\n    for (unsigned long int i = 0; i < Folder_Files.size()-1 ; i++ )\n    {\n        for( unsigned long int j = i+1; j < Folder_Files.size(); j++)\n        {\n            /*GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n            g1.Greedy_Rabin_Karp_Driver();\n            //g1.tiling();\n\n            MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n            ALL_MATCHES.push_back(m1);*/\n           //  cout << endl << endl;\n\n           Threads.push_back(thread(threading,i,j,Minimum_Matching_length));\n            //counter++;\n            cout << counter <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n        }\n\n\n    }\n\n    for(int i=0;i<Threads.size();i++){\n\n        Threads[i].join();\n    }\n    cout << endl << \"Total Compared Pairs:  \" << ALL_MATCHES.size() << endl << endl;\n    sort(ALL_MATCHES.begin(), ALL_MATCHES.end(), compare_Matches_percentage );\n\n    for(unsigned long int i = 0; i < ALL_MATCHES.size(); i++)\n    {\n        cout << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_1()].getSource_File_Name()\n             << \"   \"\n             << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_2()].getSource_File_Name();\n        cout << \"   Percent 1: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_1());\n        cout << \"   Percent 2: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_2());\n        cout << endl;\n    }\n\n\n    createJSON(ResultPath, Folder_Files, ALL_MATCHES);\n   //  createHTML(ResultPath, Folder_Files, ALL_MATCHES);\n    //createTokensHTML(ResultPath, Folder_Files, ALL_MATCHES);\n\n    return 0;\n}\n",
  "name": "main (2).cpp"
 },
 {
  "code": "#include \"header.cpp\"\n#include <thread>\n//ADD FOLLOWING LINES AS ARGUMENTS OF MAIN IF PATH IS TO BE GIVEN FROM COMMAND PROMPT\n//*int argc, char* argv[]\n\n\nvector <TOKENIZER> Folder_Files;\n\n vector <MATCHER> ALL_MATCHES;\n\n vector <thread>Threads;\n\n int counter=0;\nvoid threading(int i,int j,int Minimum_Matching_length){\n\n    GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n    g1.Greedy_Rabin_Karp_Driver();\n    //g1.tiling();\n\n    MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n    ALL_MATCHES.push_back(m1);\n\n    cout << counter++ <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n}\nint main(int argc, char* argv[])\n{\n    //C:\\Users\\user\\Desktop\\Plag_Project\\newPlag\\LAXMAN_PLAG\\testing\n    string FolderPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\testing\";   //   E:\\Plagirism_Project\\MODULAR_CODE\\Testing\\DS-EXAM 1 TREE REPLACE with argv[2];E:\\Plagirism_Project\\MODULAR_CODE\\Testing\n    string ResultPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\result\";\n    //vector <TOKENIZER> Folder_Files; // VECTOR TO STORE ALL DATA OF FILES //Folder_Files[0].;\n    string Language = \"c/c++\" ;  // REPLACE with argv[1];\n    //vector <MATCHER> ALL_MATCHES;\n    set<string> All_Languages { \"c/c++\", \"java\", \"python\" };\n    int Minimum_Matching_length = 5;\n    cout<<\"***Measure of Software Plagiarism***\" << endl << endl;\n    try\n    {\n        if(!isLanguageValid(Language, All_Languages))\n            throw  \"Error: Invalid Language!\";\n\n        if(!isPathValid(FolderPath))\n            throw  \"Error: Source Directory Not Found!\";\n\n        if(!isPathValid(ResultPath))\n            throw  \"Error: Result Directory Not Found!\";\n\n        if(!CreateTokens(Language, FolderPath, Folder_Files))\n            throw  \"Error: Directory does not have enough valid files to compare!\";\n    }\n\n    catch(const char* Error)\n    {\n        cout<<Error<<endl;\n        string  sERROR = Error;\n        if(sERROR == \"Error: Invalid Language!\")\n        {\n            cout<<\"Languages should be one of these: \";\n            for (auto itarg = All_Languages.begin(); itarg != All_Languages.end(); itarg++)\n                cout << *itarg << \",   \";\n            cout << endl;\n        }\n\n        return 0;\n    }\n\n\n    cout <<\"sensitivity:  \" << Minimum_Matching_length << endl;\n    int counter =0;\n    if(Folder_Files.size() <=1)\n        return 0;\n\n    for (unsigned long int i = 0; i < Folder_Files.size()-1 ; i++ )\n    {\n        for( unsigned long int j = i+1; j < Folder_Files.size(); j++)\n        {\n            /*GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n            g1.Greedy_Rabin_Karp_Driver();\n            //g1.tiling();\n\n            MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n            ALL_MATCHES.push_back(m1);*/\n           //  cout << endl << endl;\n\n           Threads.push_back(thread(threading,i,j,Minimum_Matching_length));\n            //counter++;\n            cout << counter <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n        }\n\n\n    }\n\n    for(int i=0;i<Threads.size();i++){\n\n        Threads[i].join();\n    }\n    cout << endl << \"Total Compared Pairs:  \" << ALL_MATCHES.size() << endl << endl;\n    sort(ALL_MATCHES.begin(), ALL_MATCHES.end(), compare_Matches_percentage );\n\n    for(unsigned long int i = 0; i < ALL_MATCHES.size(); i++)\n    {\n        cout << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_1()].getSource_File_Name()\n             << \"   \"\n             << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_2()].getSource_File_Name();\n        cout << \"   Percent 1: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_1());\n        cout << \"   Percent 2: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_2());\n        cout << endl;\n    }\n\n\n    createJSON(ResultPath, Folder_Files, ALL_MATCHES);\n   //  createHTML(ResultPath, Folder_Files, ALL_MATCHES);\n    //createTokensHTML(ResultPath, Folder_Files, ALL_MATCHES);\n\n    return 0;\n}\n",
  "name": "main (3) - Copy - Copy.cpp"
 },
 {
  "code": "#include \"header.cpp\"\n#include <thread>\n//ADD FOLLOWING LINES AS ARGUMENTS OF MAIN IF PATH IS TO BE GIVEN FROM COMMAND PROMPT\n//*int argc, char* argv[]\n\n\nvector <TOKENIZER> Folder_Files;\n\n vector <MATCHER> ALL_MATCHES;\n\n vector <thread>Threads;\n\n int counter=0;\nvoid threading(int i,int j,int Minimum_Matching_length){\n\n    GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n    g1.Greedy_Rabin_Karp_Driver();\n    //g1.tiling();\n\n    MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n    ALL_MATCHES.push_back(m1);\n\n    cout << counter++ <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n}\nint main(int argc, char* argv[])\n{\n    //C:\\Users\\user\\Desktop\\Plag_Project\\newPlag\\LAXMAN_PLAG\\testing\n    string FolderPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\testing\";   //   E:\\Plagirism_Project\\MODULAR_CODE\\Testing\\DS-EXAM 1 TREE REPLACE with argv[2];E:\\Plagirism_Project\\MODULAR_CODE\\Testing\n    string ResultPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\result\";\n    //vector <TOKENIZER> Folder_Files; // VECTOR TO STORE ALL DATA OF FILES //Folder_Files[0].;\n    string Language = \"c/c++\" ;  // REPLACE with argv[1];\n    //vector <MATCHER> ALL_MATCHES;\n    set<string> All_Languages { \"c/c++\", \"java\", \"python\" };\n    int Minimum_Matching_length = 5;\n    cout<<\"***Measure of Software Plagiarism***\" << endl << endl;\n    try\n    {\n        if(!isLanguageValid(Language, All_Languages))\n            throw  \"Error: Invalid Language!\";\n\n        if(!isPathValid(FolderPath))\n            throw  \"Error: Source Directory Not Found!\";\n\n        if(!isPathValid(ResultPath))\n            throw  \"Error: Result Directory Not Found!\";\n\n        if(!CreateTokens(Language, FolderPath, Folder_Files))\n            throw  \"Error: Directory does not have enough valid files to compare!\";\n    }\n\n    catch(const char* Error)\n    {\n        cout<<Error<<endl;\n        string  sERROR = Error;\n        if(sERROR == \"Error: Invalid Language!\")\n        {\n            cout<<\"Languages should be one of these: \";\n            for (auto itarg = All_Languages.begin(); itarg != All_Languages.end(); itarg++)\n                cout << *itarg << \",   \";\n            cout << endl;\n        }\n\n        return 0;\n    }\n\n\n    cout <<\"sensitivity:  \" << Minimum_Matching_length << endl;\n    int counter =0;\n    if(Folder_Files.size() <=1)\n        return 0;\n\n    for (unsigned long int i = 0; i < Folder_Files.size()-1 ; i++ )\n    {\n        for( unsigned long int j = i+1; j < Folder_Files.size(); j++)\n        {\n            /*GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n            g1.Greedy_Rabin_Karp_Driver();\n            //g1.tiling();\n\n            MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n            ALL_MATCHES.push_back(m1);*/\n           //  cout << endl << endl;\n\n           Threads.push_back(thread(threading,i,j,Minimum_Matching_length));\n            //counter++;\n            cout << counter <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n        }\n\n\n    }\n\n    for(int i=0;i<Threads.size();i++){\n\n        Threads[i].join();\n    }\n    cout << endl << \"Total Compared Pairs:  \" << ALL_MATCHES.size() << endl << endl;\n    sort(ALL_MATCHES.begin(), ALL_MATCHES.end(), compare_Matches_percentage );\n\n    for(unsigned long int i = 0; i < ALL_MATCHES.size(); i++)\n    {\n        cout << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_1()].getSource_File_Name()\n             << \"   \"\n             << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_2()].getSource_File_Name();\n        cout << \"   Percent 1: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_1());\n        cout << \"   Percent 2: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_2());\n        cout << endl;\n    }\n\n\n    createJSON(ResultPath, Folder_Files, ALL_MATCHES);\n   //  createHTML(ResultPath, Folder_Files, ALL_MATCHES);\n    //createTokensHTML(ResultPath, Folder_Files, ALL_MATCHES);\n\n    return 0;\n}\n",
  "name": "main (3) - Copy.cpp"
 },
 {
  "code": "#include \"header.cpp\"\n#include <thread>\n//ADD FOLLOWING LINES AS ARGUMENTS OF MAIN IF PATH IS TO BE GIVEN FROM COMMAND PROMPT\n//*int argc, char* argv[]\n\n\nvector <TOKENIZER> Folder_Files;\n\n vector <MATCHER> ALL_MATCHES;\n\n vector <thread>Threads;\n\n int counter=0;\nvoid threading(int i,int j,int Minimum_Matching_length){\n\n    GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n    g1.Greedy_Rabin_Karp_Driver();\n    //g1.tiling();\n\n    MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n    ALL_MATCHES.push_back(m1);\n\n    cout << counter++ <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n}\nint main(int argc, char* argv[])\n{\n    //C:\\Users\\user\\Desktop\\Plag_Project\\newPlag\\LAXMAN_PLAG\\testing\n    string FolderPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\testing\";   //   E:\\Plagirism_Project\\MODULAR_CODE\\Testing\\DS-EXAM 1 TREE REPLACE with argv[2];E:\\Plagirism_Project\\MODULAR_CODE\\Testing\n    string ResultPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\result\";\n    //vector <TOKENIZER> Folder_Files; // VECTOR TO STORE ALL DATA OF FILES //Folder_Files[0].;\n    string Language = \"c/c++\" ;  // REPLACE with argv[1];\n    //vector <MATCHER> ALL_MATCHES;\n    set<string> All_Languages { \"c/c++\", \"java\", \"python\" };\n    int Minimum_Matching_length = 5;\n    cout<<\"***Measure of Software Plagiarism***\" << endl << endl;\n    try\n    {\n        if(!isLanguageValid(Language, All_Languages))\n            throw  \"Error: Invalid Language!\";\n\n        if(!isPathValid(FolderPath))\n            throw  \"Error: Source Directory Not Found!\";\n\n        if(!isPathValid(ResultPath))\n            throw  \"Error: Result Directory Not Found!\";\n\n        if(!CreateTokens(Language, FolderPath, Folder_Files))\n            throw  \"Error: Directory does not have enough valid files to compare!\";\n    }\n\n    catch(const char* Error)\n    {\n        cout<<Error<<endl;\n        string  sERROR = Error;\n        if(sERROR == \"Error: Invalid Language!\")\n        {\n            cout<<\"Languages should be one of these: \";\n            for (auto itarg = All_Languages.begin(); itarg != All_Languages.end(); itarg++)\n                cout << *itarg << \",   \";\n            cout << endl;\n        }\n\n        return 0;\n    }\n\n\n    cout <<\"sensitivity:  \" << Minimum_Matching_length << endl;\n    int counter =0;\n    if(Folder_Files.size() <=1)\n        return 0;\n\n    for (unsigned long int i = 0; i < Folder_Files.size()-1 ; i++ )\n    {\n        for( unsigned long int j = i+1; j < Folder_Files.size(); j++)\n        {\n            /*GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n            g1.Greedy_Rabin_Karp_Driver();\n            //g1.tiling();\n\n            MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n            ALL_MATCHES.push_back(m1);*/\n           //  cout << endl << endl;\n\n           Threads.push_back(thread(threading,i,j,Minimum_Matching_length));\n            //counter++;\n            cout << counter <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n        }\n\n\n    }\n\n    for(int i=0;i<Threads.size();i++){\n\n        Threads[i].join();\n    }\n    cout << endl << \"Total Compared Pairs:  \" << ALL_MATCHES.size() << endl << endl;\n    sort(ALL_MATCHES.begin(), ALL_MATCHES.end(), compare_Matches_percentage );\n\n    for(unsigned long int i = 0; i < ALL_MATCHES.size(); i++)\n    {\n        cout << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_1()].getSource_File_Name()\n             << \"   \"\n             << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_2()].getSource_File_Name();\n        cout << \"   Percent 1: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_1());\n        cout << \"   Percent 2: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_2());\n        cout << endl;\n    }\n\n\n    createJSON(ResultPath, Folder_Files, ALL_MATCHES);\n   //  createHTML(ResultPath, Folder_Files, ALL_MATCHES);\n    //createTokensHTML(ResultPath, Folder_Files, ALL_MATCHES);\n\n    return 0;\n}\n",
  "name": "main (3).cpp"
 },
 {
  "code": "#include \"header.cpp\"\n#include <thread>\n//ADD FOLLOWING LINES AS ARGUMENTS OF MAIN IF PATH IS TO BE GIVEN FROM COMMAND PROMPT\n//*int argc, char* argv[]\n\n\nvector <TOKENIZER> Folder_Files;\n\n vector <MATCHER> ALL_MATCHES;\n\n vector <thread>Threads;\n\n int counter=0;\nvoid threading(int i,int j,int Minimum_Matching_length){\n\n    GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n    g1.Greedy_Rabin_Karp_Driver();\n    //g1.tiling();\n\n    MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n    ALL_MATCHES.push_back(m1);\n\n    cout << counter++ <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n}\nint main(int argc, char* argv[])\n{\n    //C:\\Users\\user\\Desktop\\Plag_Project\\newPlag\\LAXMAN_PLAG\\testing\n    string FolderPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\testing\";   //   E:\\Plagirism_Project\\MODULAR_CODE\\Testing\\DS-EXAM 1 TREE REPLACE with argv[2];E:\\Plagirism_Project\\MODULAR_CODE\\Testing\n    string ResultPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\result\";\n    //vector <TOKENIZER> Folder_Files; // VECTOR TO STORE ALL DATA OF FILES //Folder_Files[0].;\n    string Language = \"c/c++\" ;  // REPLACE with argv[1];\n    //vector <MATCHER> ALL_MATCHES;\n    set<string> All_Languages { \"c/c++\", \"java\", \"python\" };\n    int Minimum_Matching_length = 5;\n    cout<<\"***Measure of Software Plagiarism***\" << endl << endl;\n    try\n    {\n        if(!isLanguageValid(Language, All_Languages))\n            throw  \"Error: Invalid Language!\";\n\n        if(!isPathValid(FolderPath))\n            throw  \"Error: Source Directory Not Found!\";\n\n        if(!isPathValid(ResultPath))\n            throw  \"Error: Result Directory Not Found!\";\n\n        if(!CreateTokens(Language, FolderPath, Folder_Files))\n            throw  \"Error: Directory does not have enough valid files to compare!\";\n    }\n\n    catch(const char* Error)\n    {\n        cout<<Error<<endl;\n        string  sERROR = Error;\n        if(sERROR == \"Error: Invalid Language!\")\n        {\n            cout<<\"Languages should be one of these: \";\n            for (auto itarg = All_Languages.begin(); itarg != All_Languages.end(); itarg++)\n                cout << *itarg << \",   \";\n            cout << endl;\n        }\n\n        return 0;\n    }\n\n\n    cout <<\"sensitivity:  \" << Minimum_Matching_length << endl;\n    int counter =0;\n    if(Folder_Files.size() <=1)\n        return 0;\n\n    for (unsigned long int i = 0; i < Folder_Files.size()-1 ; i++ )\n    {\n        for( unsigned long int j = i+1; j < Folder_Files.size(); j++)\n        {\n            /*GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n            g1.Greedy_Rabin_Karp_Driver();\n            //g1.tiling();\n\n            MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n            ALL_MATCHES.push_back(m1);*/\n           //  cout << endl << endl;\n\n           Threads.push_back(thread(threading,i,j,Minimum_Matching_length));\n            //counter++;\n            cout << counter <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n        }\n\n\n    }\n\n    for(int i=0;i<Threads.size();i++){\n\n        Threads[i].join();\n    }\n    cout << endl << \"Total Compared Pairs:  \" << ALL_MATCHES.size() << endl << endl;\n    sort(ALL_MATCHES.begin(), ALL_MATCHES.end(), compare_Matches_percentage );\n\n    for(unsigned long int i = 0; i < ALL_MATCHES.size(); i++)\n    {\n        cout << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_1()].getSource_File_Name()\n             << \"   \"\n             << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_2()].getSource_File_Name();\n        cout << \"   Percent 1: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_1());\n        cout << \"   Percent 2: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_2());\n        cout << endl;\n    }\n\n\n    createJSON(ResultPath, Folder_Files, ALL_MATCHES);\n   //  createHTML(ResultPath, Folder_Files, ALL_MATCHES);\n    //createTokensHTML(ResultPath, Folder_Files, ALL_MATCHES);\n\n    return 0;\n}\n",
  "name": "main (4) - Copy.cpp"
 },
 {
  "code": "#include \"header.cpp\"\n#include <thread>\n//ADD FOLLOWING LINES AS ARGUMENTS OF MAIN IF PATH IS TO BE GIVEN FROM COMMAND PROMPT\n//*int argc, char* argv[]\n\n\nvector <TOKENIZER> Folder_Files;\n\n vector <MATCHER> ALL_MATCHES;\n\n vector <thread>Threads;\n\n int counter=0;\nvoid threading(int i,int j,int Minimum_Matching_length){\n\n    GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n    g1.Greedy_Rabin_Karp_Driver();\n    //g1.tiling();\n\n    MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n    ALL_MATCHES.push_back(m1);\n\n    cout << counter++ <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n}\nint main(int argc, char* argv[])\n{\n    //C:\\Users\\user\\Desktop\\Plag_Project\\newPlag\\LAXMAN_PLAG\\testing\n    string FolderPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\testing\";   //   E:\\Plagirism_Project\\MODULAR_CODE\\Testing\\DS-EXAM 1 TREE REPLACE with argv[2];E:\\Plagirism_Project\\MODULAR_CODE\\Testing\n    string ResultPath =  \"C:\\\\Users\\\\user\\\\Desktop\\\\Plag_Project\\\\newPlag\\\\LAXMAN_PLAG\\\\result\";\n    //vector <TOKENIZER> Folder_Files; // VECTOR TO STORE ALL DATA OF FILES //Folder_Files[0].;\n    string Language = \"c/c++\" ;  // REPLACE with argv[1];\n    //vector <MATCHER> ALL_MATCHES;\n    set<string> All_Languages { \"c/c++\", \"java\", \"python\" };\n    int Minimum_Matching_length = 5;\n    cout<<\"***Measure of Software Plagiarism***\" << endl << endl;\n    try\n    {\n        if(!isLanguageValid(Language, All_Languages))\n            throw  \"Error: Invalid Language!\";\n\n        if(!isPathValid(FolderPath))\n            throw  \"Error: Source Directory Not Found!\";\n\n        if(!isPathValid(ResultPath))\n            throw  \"Error: Result Directory Not Found!\";\n\n        if(!CreateTokens(Language, FolderPath, Folder_Files))\n            throw  \"Error: Directory does not have enough valid files to compare!\";\n    }\n\n    catch(const char* Error)\n    {\n        cout<<Error<<endl;\n        string  sERROR = Error;\n        if(sERROR == \"Error: Invalid Language!\")\n        {\n            cout<<\"Languages should be one of these: \";\n            for (auto itarg = All_Languages.begin(); itarg != All_Languages.end(); itarg++)\n                cout << *itarg << \",   \";\n            cout << endl;\n        }\n\n        return 0;\n    }\n\n\n    cout <<\"sensitivity:  \" << Minimum_Matching_length << endl;\n    int counter =0;\n    if(Folder_Files.size() <=1)\n        return 0;\n\n    for (unsigned long int i = 0; i < Folder_Files.size()-1 ; i++ )\n    {\n        for( unsigned long int j = i+1; j < Folder_Files.size(); j++)\n        {\n            /*GREEDY g1(Folder_Files[i].getSource_File_Token(), Folder_Files[j].getSource_File_Token(), Minimum_Matching_length);\n            g1.Greedy_Rabin_Karp_Driver();\n            //g1.tiling();\n\n            MATCHER m1(i, j, Folder_Files[i].getTokenized_File_Vector(), Folder_Files[j].getTokenized_File_Vector(), g1.getTiles());\n            ALL_MATCHES.push_back(m1);*/\n           //  cout << endl << endl;\n\n           Threads.push_back(thread(threading,i,j,Minimum_Matching_length));\n            //counter++;\n            cout << counter <<Folder_Files[i].getSource_File_Name()<<\" && \"<<Folder_Files[j].getSource_File_Name() <<endl;\n        }\n\n\n    }\n\n    for(int i=0;i<Threads.size();i++){\n\n        Threads[i].join();\n    }\n    cout << endl << \"Total Compared Pairs:  \" << ALL_MATCHES.size() << endl << endl;\n    sort(ALL_MATCHES.begin(), ALL_MATCHES.end(), compare_Matches_percentage );\n\n    for(unsigned long int i = 0; i < ALL_MATCHES.size(); i++)\n    {\n        cout << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_1()].getSource_File_Name()\n             << \"   \"\n             << Folder_Files[ALL_MATCHES[i].getFolder_Files_Index_2()].getSource_File_Name();\n        cout << \"   Percent 1: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_1());\n        cout << \"   Percent 2: \";\n        printf(\"%.2f %%\", ALL_MATCHES[i].getMatch_Percent_2());\n        cout << endl;\n    }\n\n\n    createJSON(ResultPath, Folder_Files, ALL_MATCHES);\n   //  createHTML(ResultPath, Folder_Files, ALL_MATCHES);\n    //createTokensHTML(ResultPath, Folder_Files, ALL_MATCHES);\n\n    return 0;\n}\n",
  "name": "main (5) - Copy.cpp"
 },
 {
  "code": "#include \"header.cpp\"\n\n//ADD FOLLOWING LINES AS ARGUMENTS OF MAIN IF PATH IS TO BE GIVEN FROM COMMAND PROMPT\n//*int argc, char* argv[]\nint main(int argc, char* argv[])\n{\n    string FolderPath =  \"/home/raut/Downloads/CODE/input\";     // REPLACE with argv[2];\n    vector <TOKENIZER> Folder_Files; // VECTOR TO STORE ALL DATA OF FILES        //Folder_Files[0].;\n\tstring Language = argv[1] ;  // REPLACE with argv[1];\n\n    set<string> Languages { \"c/c++\", \"java\", \"python\" };\n\tif(Languages.find(Language) == Languages.end())\n\t{\n\t\tcout<<\"Error: Invalid Language!\"<<endl;\n\t\tcout<<\"Languages should be one of these: \";\n\n\t\tfor (auto itarg = Languages.begin(); itarg != Languages.end(); itarg++) \n        \t\tcout << *itarg << \",   \";\n\n\t\tcout<<endl; \n\t\treturn 0;\n\t}\n  \n\n\n    try\n    {\n        if(!isPathValid(FolderPath))\n            throw  \"Error: Directory Not Found!\";\n        \n\tif(!CreateTokens(Language, FolderPath, Folder_Files))\n\t\tthrow  \"Error: Directory does not have enough valid files to compare!\";\n    }\n\n    catch(const char* FileError)\n    {\n        cout<<FileError<<endl;\n        return 0;\n    }\n\tcout<<\"Compared Files\"<<endl;\nint c11=0;\n    for (int i = 0; i < Folder_Files.size()-1 ; i++ )\n\t{\n\t\tfor( int j = i+1; j < Folder_Files.size(); j++)\n\t\t\t{\n\t\t\t\tcout<<Folder_Files[i].getSource_File_Name()<<\"   \"<<Folder_Files[j].getSource_File_Name()<<endl;\nc11++;\n\t\t\t}\n\t} \n\ncout<<c11<<endl;\n\n   /* if (Folder_Files[0].getTokenized_File_Vector(0).getToken_Type()==Folder_Files[1].getTokenized_File_Vector(0).getToken_Type())\n\t\t\tcout<<\"true\"<<endl;\n    else\n\t\tcout<<\"False NO match\"<<endl;\n    Folder_Files[0].getData();\n    //Folder_Files[1].getData();  */\n\n    int  Minimum_Matching_length=5;\n\t\n\tGreedy g1(Folder_Files[0].getSource_File_Token(), Folder_Files[1].getSource_File_Token(), Minimum_Matching_length);\n\tg1.Greedy_RabinKarpHash();\n\tg1.tiling();\n\t\n\n\n    return 0;\n}\n",
  "name": "main.cpp"
 }
]